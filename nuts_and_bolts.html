<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nuts & Bolts Card Prototype</title>

  <!-- Waal Bridge Resources -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
    rel="stylesheet">
  <!-- Tailwind/Custom Vars (Note: style.css defines vars in :root) -->
  <link href="./css/style.css" rel="stylesheet">

  <style>
    :root {
      /* Re-declare key vars if style.css doesn't load or for specificity within this file's scope if needed */
      --font-sans: 'Inter', sans-serif;
      --color-brand-midnight: #020617;
      --color-brand-dark: #0f172a;
      --color-brand-light: #f8fafc;
      --color-brand-accent-1: #38bdf8;
      /* Blue */
      --color-brand-accent-2: #2dd4bf;
      /* Teal */
      --color-brand-accent-3: #a855f7;
      /* Purple */
    }

    body {
      font-family: var(--font-sans);
      background-color: var(--color-brand-midnight);
      background-image: url('./WaalbridgeBackdrop.png');
      background-size: cover;
      background-position: center;
      background-attachment: fixed;
      margin: 0;
      overflow-x: hidden;
      color: var(--color-brand-light);
    }

    /* Sidebar Layout */
    #pathSidebar {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: 300px;

      /* Glass Panel Effect Waal Bridge Style */
      background: rgba(15, 23, 42, 0.6);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-right: 1px solid rgba(255, 255, 255, 0.1);

      overflow-y: auto;
      padding: 20px 0;
      box-sizing: border-box;
      z-index: 100;
      color: var(--color-brand-light);
      font-family: 'Inter', sans-serif;
    }

    #pathSidebar h3 {
      padding-left: 20px;
      margin-top: 0;
      margin-bottom: 20px;
      font-size: 1.2rem;
      text-transform: uppercase;
      font-weight: 800;
      letter-spacing: 0.05em;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 15px;

      /* Text Gradient Accent */
      background: linear-gradient(135deg, var(--color-brand-accent-1) 0%, var(--color-brand-accent-3) 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      color: var(--color-brand-accent-1);
      /* Fallback */
    }

    .sidebar-item {
      padding: 8px 20px;
      font-size: 0.95rem;
      color: #94a3b8;
      /* Slate-400 equivalent */
      transition: all 0.2s;
      position: relative;
      cursor: default;
      border-left: 2px solid transparent;
    }

    .sidebar-item.current-node {
      font-weight: 600;
      color: var(--color-brand-accent-2);
      /* Teal */
      background: rgba(45, 212, 191, 0.1);
      border-left: 2px solid var(--color-brand-accent-2);
    }

    .sidebar-item:hover {
      color: var(--color-brand-light);
      background: rgba(255, 255, 255, 0.05);
    }

    .sidebar-connector {
      position: absolute;
      left: 10px;
      top: 0;
      bottom: 0;
      border-left: 1px dashed rgba(255, 255, 255, 0.2);
    }

    .modal {
      margin-left: 300px;
      /* Offset for sidebar */
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 40px;
      box-sizing: border-box;
    }

    h2 {
      color: var(--color-brand-light);
      margin-bottom: 30px;
      text-transform: uppercase;
      letter-spacing: 2px;
      font-weight: 800;
      text-shadow: 0 0 20px rgba(56, 189, 248, 0.5);
      /* Blue Glow */
    }

    /* Grid Layout */
    .grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 30px;
      width: 100%;
      max-width: 1800px;
      transition: opacity 0.3s;
      justify-items: center;
      padding-bottom: 100px;
      /* Space for scroll */
    }

    /* Stack Container - The "Pile" */
    .stack {
      position: relative;
      width: 200px;
      height: 280px;
      perspective: 1200px;
      cursor: pointer;
      transition: transform 0.6s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.3s;
      z-index: 1;
    }

    /* The "fake" cards below the top card */
    .stack.piled::before,
    .stack.piled::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;

      /* Dark Cards */
      background: #1e293b;
      /* Slate-800 */
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);

      z-index: -1;
      transition: transform 0.3s;
    }

    /* Rotate the layers slightly to look messy */
    .stack.piled::before {
      transform: translate(2px, 3px) rotate(2deg);
    }

    .stack.piled::after {
      transform: translate(-3px, 4px) rotate(-1.5deg);
      z-index: -2;
    }

    /* Hover effect: slightly spread the stack */
    .stack.piled:hover::before {
      transform: translate(4px, 4px) rotate(4deg);
      border-color: rgba(56, 189, 248, 0.3);
      /* Blue Accent */
    }

    .stack.piled:hover::after {
      transform: translate(-6px, 6px) rotate(-3deg);
    }

    /* Focused State */
    .stack.focused {
      position: fixed;
      top: 50%;
      left: calc(50% + 150px);
      transform: translate(-50%, -50%) scale(2.6);
      /* Reduced scale slightly as cards are big */
      z-index: 1000;
      /* Ensure it doesn't get clipped if it's too big */
      max-height: 90vh;
      max-width: calc(100vw - 340px);
    }

    .stack.faded {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transition: opacity 0.3s, visibility 0.3s;
    }

    /* Card Stylings */
    .card {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      transition: transform 0.6s;
      transform-style: preserve-3d;
      z-index: 2;
      /* Ensure top card is above the stack pile pseudo-elements */
    }

    .card.flip {
      transform: rotateY(180deg);
    }

    .card .front,
    .card .back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      border-radius: 12px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px;
      box-sizing: border-box;

      /* Glassmorphism Base */
      background: rgba(30, 41, 59, 0.7);
      /* Dark Glass */
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
    }

    /* Playing Card "Face" Pattern (Simplified) */
    .card .front {
      /* Front Specifics */
      background: rgba(15, 23, 42, 0.85);
      /* Slightly darker/more opaque for readability */
      padding: 24px;
      border: 1px solid rgba(56, 189, 248, 0.2);
      /* Subtle Blue Border */
    }

    /* Corners for Rank/Suit */
    .corner {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      line-height: 1;
      font-weight: bold;
      font-size: 1.2rem;
      padding: 8px;
      color: var(--color-brand-light);
      /* Default color */
    }

    .top-left {
      top: 5px;
      left: 5px;
    }

    .bottom-right {
      bottom: 5px;
      right: 5px;
      transform: rotate(180deg);
    }

    .card-content-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      padding: 0 10px;
      /* Reduced side padding */
      width: 100%;
    }

    .card-title {
      font-family: 'Courier New', Courier, monospace;
      /* Kept for "Nuts & Bolts" label feel */
      font-weight: 900;
      letter-spacing: 1px;
      font-size: 0.85rem;
      color: var(--color-brand-accent-1);
      /* Blue for titles */
      text-shadow: 0 0 10px rgba(56, 189, 248, 0.3);
      margin-top: 10px;
    }

    .card .back {
      transform: rotateY(180deg);

      /* Back Specifics - Waal Bridge Dark Glass */
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(168, 85, 247, 0.3);
      /* Purple Border for back */
      box-shadow: 0 0 15px rgba(168, 85, 247, 0.15);
      /* Purple Glow */

      color: var(--color-brand-light);
      justify-content: space-between;
      padding: 20px;
    }

    /* New Back Styles - FlipCardApp Design */
    /* New Back Styles - FlipCardApp Design */
    /* Sizes are reduced to compensate for 2.6x scale when focused */
    .card-description-input {
      font-size: 0.5rem;
      text-align: left;
      flex-grow: 1;
      width: 100%;
      padding: 6px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 4px;

      /* Dark Input Style */
      background-color: rgba(0, 0, 0, 0.3);
      color: var(--color-brand-light);
      font-family: 'Inter', sans-serif;

      resize: none;
      min-height: 50px;
      box-sizing: border-box;
      margin-top: 4px;
      outline: none;
    }

    .card-description-input:focus {
      border-color: var(--color-brand-accent-1);
    }

    .checkbox-container {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin: 4px 0;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 3px;
      cursor: pointer;
      font-size: 0.5rem;
      font-weight: 500;
      color: #94a3b8;
      /* Slate-400 */
    }

    .checkbox-label input[type="checkbox"] {
      width: 8px;
      height: 8px;
      cursor: pointer;
      accent-color: var(--color-brand-accent-2);
      /* Teal Checkbox */
    }

    /* Buttons - Sizes reduced to compensate for 2.6x scale */
    .explore-btn {
      padding: 4px 12px;
      border: none;
      border-radius: 3px;

      /* Gradient Button */
      background: linear-gradient(90deg, var(--color-brand-accent-1), var(--color-brand-accent-2));
      color: var(--color-brand-midnight);

      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.5rem;
      margin-top: 2px;
      align-self: center;
      box-shadow: 0 2px 5px rgba(56, 189, 248, 0.3);
    }

    .explore-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(56, 189, 248, 0.5);
      filter: brightness(1.1);
    }

    .explore-btn:disabled {
      background: #475569;
      /* Slate-600 */
      color: #94a3b8;
      cursor: not-allowed;
      opacity: 0.6;
      box-shadow: none;
      transform: none;
    }

    /* Back Button */
    .navigation-controls {
      position: sticky;
      top: 20px;
      /* Centered in flex column modal */
      align-self: center;
      display: flex;
      gap: 20px;
      z-index: 2000;
      pointer-events: none;
      /* Let clicks pass through empty space */
      margin-bottom: 20px;
      /* Space between buttons and cards */
    }

    .back-button {
      display: none;
      /* Toggled via JS */
      padding: 10px 24px;

      /* Waal Bridge Gradient */
      background: linear-gradient(90deg, var(--color-brand-accent-1), var(--color-brand-accent-2));
      color: var(--color-brand-midnight);

      border: none;
      border-radius: 9999px;
      /* Pill shape */
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      box-shadow: 0 4px 15px rgba(56, 189, 248, 0.3);
      pointer-events: auto;
      /* Re-enable clicks on buttons */
      transition: all 0.3s;
    }

    .back-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(56, 189, 248, 0.5);
      filter: brightness(1.1);
    }

    #upLevelBtn {
      background: linear-gradient(90deg, var(--color-brand-accent-3), #d946ef);
      /* Purple to Pink */
      box-shadow: 0 4px 15px rgba(168, 85, 247, 0.3);
    }

    #upLevelBtn:hover {
      box-shadow: 0 6px 20px rgba(168, 85, 247, 0.5);
    }

    /* Popup */
    .diagram-popup {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(2, 6, 23, 0.95);
      /* Midnight almost opaque */
      z-index: 3000 !important;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      backdrop-filter: blur(5px);
    }

    .diagram-popup img {
      max-width: 90%;
      max-height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 50px rgba(56, 189, 248, 0.3);
      /* Blue Glow */
      border: 1px solid rgba(56, 189, 248, 0.2);
    }

    .close-btn {
      color: var(--color-brand-light);
      font-size: 3rem;
      position: absolute;
      top: 30px;
      right: 40px;
      cursor: pointer;
      transition: color 0.2s;
    }

    .close-btn:hover {
      color: var(--color-brand-accent-3);
      /* Purple hover */
    }

    .caption {
      color: var(--color-brand-light);
      margin-top: 20px;
      font-size: 1.2rem;
      font-weight: 300;
    }

    /* Pagination */
    .pagination {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 40px;
      margin-bottom: 40px;
    }

    .page-btn {
      padding: 10px 15px;
      background: rgba(30, 41, 59, 0.5);
      color: #94a3b8;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
    }

    .page-btn.active {
      background: var(--color-brand-accent-1);
      color: var(--color-brand-midnight);
      border-color: var(--color-brand-accent-1);
      box-shadow: 0 0 10px rgba(56, 189, 248, 0.4);
    }

    .page-btn:hover:not(.active) {
      background: rgba(56, 189, 248, 0.2);
      color: white;
    }

    .child-indicator {
      position: absolute;
      bottom: 15px;
      left: 15px;
      width: 12px;
      height: 12px;
      background-color: var(--color-brand-accent-2);
      /* Teal */
      border-radius: 50%;
      z-index: 10;
      box-shadow: 0 0 8px rgba(45, 212, 191, 0.6);
      border: 1px solid white;
    }

    .flip-button {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 30px;
      height: 30px;
      background-color: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      font-size: 18px;
      color: var(--color-brand-light);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      user-select: none;
      display: none;
      transition: all 0.2s;
    }

    /* Ensure flip button on back is visible */
    .card .back .flip-button {
      display: flex;
      background-color: rgba(255, 255, 255, 0.1);
    }

    .stack.focused .flip-button {
      display: flex;
    }

    .flip-button:hover {
      background-color: var(--color-brand-accent-1);
      color: var(--color-brand-midnight);
      transform: scale(1.1);
      border-color: var(--color-brand-accent-1);
    }
  </style>

</head>

<body>

  <div id="pathSidebar">
    <!-- Back Navigation -->
    <a href="index.html"
      class="block px-5 py-4 mb-4 border-b border-white/10 text-brand-accent-1 hover:text-white hover:bg-white/5 transition-all group no-underline">
      <div class="flex items-center gap-2">
        <svg class="w-4 h-4 group-hover:-translate-x-1 transition-transform" fill="none" viewBox="0 0 24 24"
          stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
        </svg>
        <span class="font-bold text-sm tracking-wide uppercase">Back to Portfolio</span>
      </div>
    </a>

    <!-- Raw Data Viewer -->
    <a href="/view-raw-data" target="_blank"
      class="block px-5 py-4 mb-4 border-b border-white/10 text-brand-accent-1 hover:text-white hover:bg-white/5 transition-all group no-underline">
      <div class="flex items-center gap-2">
        <span class="font-bold text-sm tracking-wide uppercase">Raw Data Viewer</span>
      </div>
    </a>

    <h3>Current Path</h3>
    <div id="pathList"></div>
  </div>

  <div class="modal">
    <!-- Navigation Controls Container -->
    <div class="navigation-controls" id="navControls">
      <button class="back-button" id="backButton">Back to Grid</button>
      <button class="back-button" id="upLevelBtn" style="background-color: #27ae60;">Up One Level</button>
    </div>

    <div class="grid" id="stackGrid"></div>
    <div class="pagination" id="pagination"></div>
  </div>

  <div class="diagram-popup" id="diagramPopup">
    <span class="close-btn" onclick="closeDiagram()">× Close</span>
    <img id="diagramImage" src="" alt="Diagram">
    <div id="diagramCaption"></div>
  </div>

  <div class="diagram-popup" id="mediaSelectionPopup" style="background: rgba(0,0,0,0.9);">
    <span class="close-btn" onclick="closeMediaSelection()">× Close</span>
    <h2 style="color: white; margin-bottom: 20px;">Select an Image</h2>
    <div id="mediaSelectionContainer" style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;"></div>
  </div>

  <div class="diagram-popup" id="jsonErrorModal" style="background: rgba(50, 0, 0, 0.95); z-index: 9999;">
    <div
      style="text-align: center; max-width: 600px; padding: 40px; border: 2px solid #ef4444; border-radius: 16px; background: #1e293b; color: white; display: flex; flex-direction: column; gap: 20px; box-shadow: 0 0 50px rgba(239, 68, 68, 0.5);">
      <div style="font-size: 4rem; color: #ef4444;">⚠️</div>
      <h2 style="color: #ef4444; margin: 0; font-size: 2rem;">Data Loading Error</h2>
      <p style="font-size: 1.1rem; line-height: 1.6; color: #cbd5e1;">There was a problem loading the project data. This
        is usually caused by a syntax error in <strong>cards.json</strong> or <strong>relationships.json</strong>.</p>

      <div id="jsonErrorMessage"
        style="background: #0f172a; padding: 15px; border-radius: 8px; font-family: monospace; text-align: left; color: #fca5a5; font-size: 0.9rem; overflow-x: auto; border: 1px solid #7f1d1d;">
        Error details...
      </div>

      <button onclick="location.reload()"
        style="padding: 12px 24px; background: #ef4444; color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 1rem; cursor: pointer; transition: all 0.2s; text-transform: uppercase; letter-spacing: 1px;">
        Reload App
      </button>
    </div>
  </div>

  <script>
    let cards = {};
    let relationships = [];
    let currentStackId = null;
    let breadcrumbs = [];

    // wrapper to fetch and check json
    const fetchJson = (url) => {
      return fetch(url + '?t=' + Date.now())
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status} for ${url}`);
          }
          return response.json();
        })
        .catch(err => {
          throw new Error(`Failed to load ${url}: ${err.message}`);
        });
    };

    // Load Data
    Promise.all([
      fetchJson('cards.json'),
      fetchJson('relationships.json')
    ]).then(([cardsData, relationshipsData]) => {
      // Handle wrappers if present (user provided files have 'cards' and 'relationships' keys)
      const cList = cardsData.cards || cardsData;
      const rList = relationshipsData.relationships || relationshipsData;

      cList.forEach(c => cards[c.id] = c);
      relationships = rList;
      init();
    }).catch(err => {
      console.error("Critical Data Error:", err);
      const modal = document.getElementById('jsonErrorModal');
      const msg = document.getElementById('jsonErrorMessage');
      if (modal && msg) {
        msg.textContent = err.message;
        modal.style.display = 'flex'; // Use flex to center with existing class
      }
    });

    function init() {
      // Find top-level stacks and assign Suit/Rank 
      const suits = ['♠', '♥', '♣', '♦'];
      // User request: "They can all be aces"
      const rank = 'A';

      const allCards = Object.values(cards);
      allCards.forEach((c, index) => {
        const suit = suits[index % suits.length];
        c.suit = suit;
        c.rank = rank;
        c.color = (suit === '♥' || suit === '♦') ? '#e74c3c' : '#2c3e50';
      });

      renderRoot();
    }

    // Navigation
    function renderRoot() {
      currentStackId = null;
      breadcrumbs = [];
      updateBreadcrumbs();

      const rootStacks = Object.values(cards).filter(c => c.type === 'stack');
      // Sort by ID to ensure order if needed, assuming numeric prefixes in IDs like '001_'
      rootStacks.sort((a, b) => a.id.localeCompare(b.id));
      renderGrid(rootStacks);
    }

    function renderGrid(cardList) {
      const grid = document.getElementById('stackGrid');
      grid.innerHTML = '';

      cardList.forEach(card => {
        const cardEl = createCardElement(card);
        grid.appendChild(cardEl);
      });
    }

    function createCardElement(card) {
      const el = document.createElement('div');

      // Helper functions for relationships
      const getSource = (r) => r.source || r.from;
      const getTarget = (r) => r.target || r.to;

      el.className = 'stack'; // Using 'stack' class for main grid items for now

      const hasChildren = relationships.some(r => (r.source || r.from) === card.id && (r.type === 'contains' || r.type === 'leads_to'));
      const indicatorHtml = hasChildren ? '<div class="child-indicator" title="Click to view more details"></div>' : '';

      el.className = 'stack'; // Base class
      if (hasChildren) {
        el.classList.add('piled');
      }

      // Determine contents for back of card
      const description = card.description || card.details || card.title || "No description available.";

      // Image Logic: Prefer displayImages.front.url -> card_image -> boltandnut.png
      let frontImage = null;
      if (card.displayImages && card.displayImages.front && card.displayImages.front.url) {
        frontImage = card.displayImages.front.url;
      } else if (card.card_image) {
        frontImage = card.card_image;
      }

      // Back image logic
      const imageSrc = card.card_image || "boltandnut.png";

      // Determine media availability
      let hasPdf = false;
      let hasGraphic = false;
      let hasWeb = false;
      let hasVideo = false;

      if (card.media && Array.isArray(card.media)) {
        hasPdf = card.media.some(file => file.toLowerCase().endsWith('.pdf'));
        hasGraphic = card.media.some(file => {
          const f = file.toLowerCase();
          return f.endsWith('.png') || f.endsWith('.jpg') || f.endsWith('.jpeg') || f.endsWith('.gif') || f.endsWith('.webp');
        });
      }

      // Check for new fields
      if (card.web && card.web.trim().length > 0) {
        hasWeb = true;
      }
      if (card.video && card.video.trim().length > 0) {
        hasVideo = true;
      }

      // Auto-enable view button if content exists
      const viewDisabled = (!hasPdf && !hasGraphic && !hasWeb && !hasVideo) ? 'disabled' : '';

      el.innerHTML = `
        <div class="card">
            <div class="front" style="color: ${card.color || 'black'}; background-color: ${card.frontBackgroundColor || '#fafafa'};">
                <div class="flip-button" title="Flip Card">⟳</div>
                ${indicatorHtml}
                <div class="corner top-left">
                    <div class="suit"><img src="boltandnut.png" alt="suit" style="width: 24px; height: auto; filter: sepia(1) hue-rotate(90deg) saturate(3) brightness(0.9);"></div>
                </div>
                
                <div class="card-content-wrapper">
                   ${frontImage ? `<div class="card-image-custom"><img src="${frontImage}" alt="Card Image" style="max-width: 100%; height: 65px; object-fit: contain; margin-bottom: 10px;"></div>` : ''}
                   <div class="card-title">${card.title}</div>
                </div>

                <div class="corner bottom-right">
                    <div class="suit"><img src="boltandnut.png" alt="suit" style="width: 24px; height: auto; filter: sepia(1) hue-rotate(90deg) saturate(3) brightness(0.9);"></div>
                </div>
            </div>
            <div class="back">
                <div class="flip-button" title="Flip Card">⟳</div>
                
                <textarea class="card-description-input" readonly>${card.title}\n\n${description}</textarea>
                
                <div class="checkbox-container">
                    <label class="checkbox-label">
                        <input type="checkbox" class="pdf-checkbox" name="pdf" ${hasPdf ? 'checked' : ''} disabled>
                        <span>PDF</span>
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" class="graphic-checkbox" name="graphic" ${hasGraphic ? 'checked' : ''} disabled>
                        <span>Graphic</span>
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" class="web-checkbox" name="web" ${hasWeb ? 'checked' : ''} disabled>
                        <span>Web</span>
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" class="video-checkbox" name="video" ${hasVideo ? 'checked' : ''} disabled>
                        <span>Video</span>
                    </label>
                </div>
                
                <button class="explore-btn" ${viewDisabled}>View</button>
            </div>
        </div>
      `;

      // Flip button Logic
      const cardInner = el.querySelector('.card');
      const flipButtons = el.querySelectorAll('.flip-button');
      flipButtons.forEach(btn => {
        btn.onclick = (e) => {
          e.stopPropagation(); // Stop bubbling to card click
          cardInner.classList.toggle('flip');
        };
      });

      // Checkbox validation logic for View button removed as checkboxes are now readonly.
      // View button state is set initially based on content.
      const pdfCheckbox = el.querySelector('.pdf-checkbox');
      const graphicCheckbox = el.querySelector('.graphic-checkbox');

      // Explore Button Logic
      const exploreBtn = el.querySelector('.explore-btn');
      exploreBtn.onclick = (e) => {
        e.stopPropagation();

        // 1. Aggregate all media types
        let allMedia = [];

        // PDF / Images from card.media
        if (card.media) {
          let mediaList = [];
          if (Array.isArray(card.media)) {
            mediaList = card.media.flatMap(m => m.split(',').map(s => s.trim()));
          } else if (typeof card.media === 'string') {
            mediaList = card.media.split(',').map(s => s.trim());
          }

          mediaList.forEach(m => {
            let cleanPath = m.trim();
            // Remove existing prefixes if present (for robustness during migration)
            cleanPath = cleanPath.replace(/^(pdf|images)[\\/]/i, '');

            const lower = cleanPath.toLowerCase();
            let type = 'image';
            let finalPath = cleanPath;

            if (lower.endsWith('.pdf')) {
              type = 'pdf';
              finalPath = 'pdf/' + cleanPath;
            } else {
              // Assume image
              finalPath = 'images/' + cleanPath;
            }

            allMedia.push({ type: type, value: finalPath, title: cleanPath });
          });
        }

        // Web Link
        if (card.web && card.web.trim().length > 0) {
          const links = card.web.split(',');
          links.forEach(link => {
            const url = link.trim();
            if (url) {
              allMedia.push({ type: 'web', value: url, title: 'Web Link' });
            }
          });
        }

        // Video
        if (card.video && card.video.trim().length > 0) {
          const videos = card.video.split(',');
          videos.forEach(v => {
            // Assuming video is in 'Videos/' subdirectory if it doesn't have a path
            let vPath = v.trim();

            // Clean up path separators
            vPath = vPath.replace(/\\/g, '/');
            if (vPath.startsWith('/')) vPath = vPath.substring(1);

            if (vPath && !vPath.includes('/')) {
              vPath = 'Videos/' + vPath;
            }
            if (vPath) {
              allMedia.push({ type: 'video', value: vPath, title: 'Video' });
            }
          });
        }

        // 2. Decide Action
        if (allMedia.length > 0) {
          if (allMedia.length === 1) {
            showMedia(allMedia[0]);
          } else {
            showMediaSelection(allMedia);
          }
          return;
        }

        // Fallback to legacy relationship-based media (preserve existing logic)
        const mediaRels = relationships.filter(r => getSource(r) === card.id && r.type === 'show_media');

        if (mediaRels.length > 0) {
          const targetId = getTarget(mediaRels[0]);
          if (cards[targetId]) {
            // For legacy, we just assume it's an image/pdf on the target card
            // We'll wrap it in our new structure to be safe, or showMedia needs to handle raw cards too?
            // The existing showMedia took a card. Let's make showMedia handle both for backward compat or update this.
            // Simplest: construct a mock item
            let mSrc = (typeof cards[targetId].media === 'string') ? cards[targetId].media : cards[targetId].card_image;
            if (Array.isArray(cards[targetId].media)) mSrc = cards[targetId].media[0];

            let type = 'image';
            if (mSrc && mSrc.toLowerCase().endsWith('.pdf')) type = 'pdf';

            showMedia({ type: type, value: mSrc, title: cards[targetId].title });
          }
        } else {
          console.log("No media to explore for this card.");
        }
      };

      // Card Grid Click Logic (Focus Interaction)
      el.onclick = (e) => {
        // Ignore clicks on buttons or interactive elements
        if (e.target.closest('button') || e.target.closest('.flip-button') || e.target.closest('.explore-btn') || e.target.closest('.child-indicator')) return;

        if (el.classList.contains('focused')) {
          // "Currently if you click on anywhere other than the button you display the childen of the big card."
          // So clicking a focused card should drill down.

          const hasKids = relationships.some(r => (r.source || r.from) === card.id && (r.type === 'contains' || r.type === 'leads_to'));
          if (hasKids) {
            navigateTo(card);
          } else {
            // Leaf node: fallback to flip toggle if no children
            const cardInner = el.querySelector('.card');
            cardInner.classList.toggle('flip');
          }
        } else {
          // Not focused, just focus
          focusStack(el);
        }
      };

      return el;
    }

    function focusStack(stackEl) {
      if (stackEl.classList.contains('focused')) {
        return;
      }

      const grid = document.getElementById('stackGrid');
      // Fade out others
      Array.from(grid.children).forEach(child => {
        if (child !== stackEl) child.classList.add('faded');
      });

      stackEl.classList.add('focused');
      document.getElementById('backButton').style.display = 'block';
      document.querySelector('.navigation-controls').style.display = 'flex';
    }

    function clearFocus() {
      const grid = document.getElementById('stackGrid');
      if (grid) {
        Array.from(grid.children).forEach(child => {
          child.classList.remove('faded');
          child.classList.remove('focused');
          const card = child.querySelector('.card');
          if (card) card.classList.remove('flip');
        });
      }
    }

    document.getElementById('backButton').onclick = () => {
      clearFocus();

      // If we are drilled down, "Back to Grid" means "Home" / "Top Level"
      if (breadcrumbs.length > 0) {
        renderRoot();
        // renderRoot handles breadcrumbs reset and UI updates
        return;
      }

      // If we are at root (breadcrumbs.length === 0), just unfocus (which we did above)
      document.getElementById('backButton').style.display = 'none';
      document.querySelector('.navigation-controls').style.display = 'none';
    };

    function navigateTo(parentCard, specificChild = null) {
      // No need to click backButton, it resets breadcrumbs! 
      // Just proceed to render new level.

      // Update State
      currentStackId = parentCard.id;
      breadcrumbs.push(parentCard);
      updateBreadcrumbs();

      const grid = document.getElementById('stackGrid');
      grid.innerHTML = '';

      const getSource = (r) => r.source || r.from;
      const getTarget = (r) => r.target || r.to;

      let itemsToShow = [];
      if (specificChild) {
        itemsToShow = [specificChild];
      } else {
        const childrenIds = relationships
          .filter(r => getSource(r) === parentCard.id && r.type === 'contains')
          .map(r => getTarget(r));
        itemsToShow = childrenIds.map(id => cards[id]);
      }

      // If no children found for a stack
      if (itemsToShow.length === 0) {
        grid.innerHTML = '<div style="color:white; text-align:center; width:100%;">No items found in this category.</div>';
        return;
      }

      itemsToShow.forEach(c => {
        if (!c) return;
        grid.appendChild(createCardElement(c));
      });
    }


    function updateBreadcrumbs() {
      // Sidebar Update
      updateSidebar();

      // Top Breadcrumbs (Home > ...) removed as per user request (replaced by sidebar)
      /*
      let bcContainer = document.getElementById('breadcrumbs');
      if (!bcContainer) {
         // ...
      }
      */
      // Ensure existing specific breadcrumb container is removed if it exists from previous renders
      let bcContainer = document.getElementById('breadcrumbs');
      if (bcContainer) {
        bcContainer.style.display = 'none';
      }

      const upBtn = document.getElementById('upLevelBtn');
      if (breadcrumbs.length > 0) {
        upBtn.style.display = 'block';
        upBtn.onclick = () => {
          // If a card is currently focused, unfocus it first
          const focusedCard = document.querySelector('.focused');
          if (focusedCard) {
            clearFocus();
            focusedCard.classList.remove('focused');
            // If the user wants "Up One Level" to effectively mean "Back to the grid I was just looking at", 
            // then we stop here because we just revealed the grid.
            // But if "Up One Level" means "Go to Parent Stack", we should proceed?
            // Current behavior: Button says "Up One Level". 
            // If I am zoomed in on a card, "Up" is "Zoom Out back to grid". 
            return;
          }

          if (breadcrumbs.length === 1) {
            renderRoot();
          } else {
            jumpToCrumb(breadcrumbs.length - 2);
          }
        };
      }

      const navControls = document.querySelector('.navigation-controls');
      if (navControls) {
        // Show controls if we are deep in hierarchy OR if a card is focused (handled by focusStack usually, but nice to be robust)
        // User wants buttons visible "all the time appart from the top level stack card view"
        if (breadcrumbs.length > 0) {
          navControls.style.display = 'flex';
          document.getElementById('backButton').style.display = 'block';
        } else {
          // At root. Only show if a card is focused (handled by focusStack). 
          // If no card is focused, hide.
          if (!document.querySelector('.focused')) {
            navControls.style.display = 'none';
          }
        }
      }
    }

    function updateSidebar() {
      const container = document.getElementById('pathList');
      if (!container) return;
      container.innerHTML = '';

      // Build path array: Home + breadcrumbs
      const path = [{ title: 'Home', id: 'root' }, ...breadcrumbs];

      path.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'sidebar-item';

        // Indentation
        div.style.paddingLeft = (20 + (index * 15)) + 'px';

        // Current Node Highlight
        if (index === path.length - 1) {
          div.classList.add('current-node');
        }

        // Reduced interactivity significantly as per user request "Sidebar is readonly"
        // No click handlers here.

        div.textContent = item.title || item.id;
        container.appendChild(div);
      });

      // Auto-scroll to bottom of sidebar
      const sidebar = document.getElementById('pathSidebar');
      sidebar.scrollTop = sidebar.scrollHeight;
    }


    function jumpToCrumb(index) {
      // targetCard is the card at index (0-based in breadcrumbs)
      const targetCard = breadcrumbs[index];

      // Slice breadcrumbs to include up to index (so we keep 0..index)
      // correct slice is (0, index + 1)
      breadcrumbs = breadcrumbs.slice(0, index + 1);
      currentStackId = targetCard.id;

      // Clear focus if any
      const grid = document.getElementById('stackGrid');
      if (grid) {
        Array.from(grid.children).forEach(child => child.classList.remove('focused', 'faded'));
      }
      document.getElementById('backButton').style.display = 'none';

      updateBreadcrumbs();

      // Render content
      const gridEl = document.getElementById('stackGrid');
      gridEl.innerHTML = '';

      const getSource = (r) => r.source || r.from;
      const getTarget = (r) => r.target || r.to;

      const childrenIds = relationships
        .filter(r => getSource(r) === targetCard.id && r.type === 'contains')
        .map(r => getTarget(r));

      let itemsToShow = childrenIds.map(id => cards[id]);

      if (itemsToShow.length === 0) {
        gridEl.innerHTML = '<div style="color:white; text-align:center;">No items found.</div>';
      } else {
        itemsToShow.forEach(c => {
          if (c) gridEl.appendChild(createCardElement(c));
        });
      }
    }
    window.renderRoot = renderRoot;

    function showMedia(item) {
      console.log("showMedia called with:", item);

      // Handle Web
      if (item.type === 'web') {
        window.open(item.value, '_blank');
        return;
      }

      // Detect media type
      const popupContent = document.getElementById('diagramPopup');
      // Clear existing content except caption/close
      const imgEl = document.getElementById('diagramImage');
      const captionEl = document.getElementById('diagramCaption');

      // Helper to reset popup
      const resetPopup = () => {
        imgEl.style.display = 'none';
        const existingIframe = document.getElementById('pdfFrame');
        if (existingIframe) existingIframe.remove();
        const existingVideo = document.getElementById('videoPlayer');
        if (existingVideo) existingVideo.remove();
        const existingErr = document.getElementById('imgError');
        if (existingErr) existingErr.remove();
      };
      resetPopup();

      if (item.type === 'pdf') {
        console.log("Displaying as PDF");

        const iframe = document.createElement('iframe');
        iframe.id = 'pdfFrame';
        iframe.src = item.value;
        iframe.style.width = '90%';
        iframe.style.height = '80vh';
        iframe.style.border = 'none';
        iframe.style.borderRadius = '8px';
        iframe.style.boxShadow = '0 0 50px rgba(0, 0, 0, 0.5)';

        popupContent.insertBefore(iframe, captionEl);
      } else if (item.type === 'video') {
        console.log("Displaying as Video");

        const video = document.createElement('video');
        video.id = 'videoPlayer';
        video.controls = true;
        video.autoplay = true;
        video.style.width = '90%';
        video.style.maxHeight = '80vh';
        video.style.borderRadius = '8px';
        video.style.boxShadow = '0 0 50px rgba(0, 0, 0, 0.5)';

        const source = document.createElement('source');
        source.src = item.value;
        source.type = 'video/mp4';
        video.appendChild(source);

        popupContent.insertBefore(video, captionEl);
      } else {
        console.log("Displaying as Image");
        imgEl.style.display = 'block';
        imgEl.src = item.value || '';
        imgEl.onerror = function () {
          this.style.display = 'none';
          const errDiv = document.createElement('div');
          errDiv.id = 'imgError';
          errDiv.style.color = 'white';
          errDiv.style.textAlign = 'center';
          errDiv.innerHTML = '<h3>Image Not Found</h3><p>' + (item.value || 'No source provided') + '</p>';
          popupContent.insertBefore(errDiv, captionEl);
        };
      }

      captionEl.textContent = item.title || '';
      popupContent.style.display = 'flex';
    }

    function showMediaSelection(items) {
      const container = document.getElementById('mediaSelectionContainer');
      container.innerHTML = ''; // Clear previous

      items.forEach(item => {
        const btn = document.createElement('div');
        btn.style.cssText = `
                width: 150px; 
                height: 150px; 
                border: 2px solid white; 
                border-radius: 8px; 
                overflow: hidden; 
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                background: #333;
                flex-direction: column;
            `;

        let previewHtml = '';
        if (item.type === 'pdf') {
          previewHtml = `<div style="width: 100%; height: 100px; display: flex; align-items: center; justify-content: center; background: #e74c3c; color: white; font-weight: bold; font-size: 24px;">PDF</div>`;
        } else if (item.type === 'video') {
          previewHtml = `<div style="width: 100%; height: 100px; display: flex; align-items: center; justify-content: center; background: #8e44ad; color: white; font-weight: bold; font-size: 24px;">▶</div>`;
        } else if (item.type === 'web') {
          previewHtml = `<div style="width: 100%; height: 100px; display: flex; align-items: center; justify-content: center; background: #2980b9; color: white; font-weight: bold; font-size: 24px;">WWW</div>`;
        } else {
          // Image
          previewHtml = `<img src="${item.value}" style="width: 100%; height: 100px; object-fit: cover; margin-bottom: 5px;">`;
        }

        btn.innerHTML = `
                ${previewHtml}
                <span style="color: white; font-size: 0.8rem; word-break: break-all; padding: 2px; text-transform: capitalize; text-align: center;">${item.title || item.value}</span>
            `;

        btn.onclick = () => {
          closeMediaSelection();
          showMedia(item);
        };

        container.appendChild(btn);
      });

      document.getElementById('mediaSelectionPopup').style.display = 'flex';
    }

    function closeMediaSelection() {
      document.getElementById('mediaSelectionPopup').style.display = 'none';
    }

    function closeDiagram() {
      // Pause video if playing
      const v = document.getElementById('videoPlayer');
      if (v) v.pause();

      document.getElementById('diagramPopup').style.display = 'none';
    }

    // Clean up pagination as it's not strictly compatible with the drill-down unless we re-implement it per level
    document.getElementById('pagination').style.display = 'none';
    document.getElementById('backButton').style.display = 'none'; // Replaced by breadcrumbs

    // Project Video Button Logic
    document.getElementById('projectVideoBtn').onclick = () => {
      showMedia({
        type: 'video',
        value: 'Videos/Waal_Bridge__Harmonising_Tech.mp4',
        title: 'Project Overview'
      });
    };

  </script>

</body>

</html>