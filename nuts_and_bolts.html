<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nuts & Bolts Card Prototype</title>

  <!-- Waal Bridge Resources -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
    rel="stylesheet">
  <!-- Tailwind/Custom Vars (Note: style.css defines vars in :root) -->
  <link href="./css/style.css" rel="stylesheet">
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    :root {
      /* Re-declare key vars if style.css doesn't load or for specificity within this file's scope if needed */
      --font-sans: 'Inter', sans-serif;
      --color-brand-midnight: #020617;
      --color-brand-dark: #0f172a;
      --color-brand-light: #f8fafc;
      --color-brand-accent-1: #38bdf8;
      /* Blue */
      --color-brand-accent-2: #2dd4bf;
      /* Teal */
      --color-brand-accent-3: #a855f7;
      /* Purple */
    }

    body {
      font-family: var(--font-sans);
      background-color: var(--color-brand-midnight);
      background-image: url('./WaalbridgeBackdrop.png');
      background-size: cover;
      background-position: center;
      background-attachment: fixed;
      margin: 0;
      overflow-x: hidden;
      color: var(--color-brand-light);
    }

    /* Sidebar Layout */
    #pathSidebar {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: 300px;
      background: rgba(15, 23, 42, 0.6);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      overflow-y: auto;
      padding: 20px 0;
      box-sizing: border-box;
      z-index: 100;
      color: var(--color-brand-light);
      font-family: 'Inter', sans-serif;
    }

    /* Right Sidebar for Strategic Trails */
    #strategicSidebar {
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
      width: 300px;
      /* Glass Panel Effect Waal Bridge Style */
      background: rgba(15, 23, 42, 0.6);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-left: 1px solid rgba(255, 255, 255, 0.1);
      overflow-y: auto;
      padding: 20px;
      box-sizing: border-box;
      z-index: 100;
      color: var(--color-brand-light);
      font-family: 'Inter', sans-serif;
    }

    #strategicSidebar h3 {
      margin-top: 0;
      margin-bottom: 20px;
      font-size: 1.2rem;
      text-transform: uppercase;
      font-weight: 800;
      letter-spacing: 0.05em;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 15px;
      /* Text Gradient Accent */
      background: linear-gradient(135deg, var(--color-brand-accent-1) 0%, var(--color-brand-accent-3) 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      color: var(--color-brand-accent-1);
    }

    #pathSidebar h3 {
      padding-left: 20px;
      margin-top: 0;
      margin-bottom: 20px;
      font-size: 1.2rem;
      text-transform: uppercase;
      font-weight: 800;
      letter-spacing: 0.05em;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding-bottom: 15px;

      /* Text Gradient Accent */
      background: linear-gradient(135deg, var(--color-brand-accent-1) 0%, var(--color-brand-accent-3) 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      color: var(--color-brand-accent-1);
      /* Fallback */
    }

    .sidebar-item {
      padding: 8px 20px;
      font-size: 0.95rem;
      color: #94a3b8;
      /* Slate-400 equivalent */
      transition: all 0.2s;
      position: relative;
      cursor: default;
      border-left: 2px solid transparent;
    }

    .sidebar-item.current-node {
      font-weight: 600;
      color: var(--color-brand-accent-2);
      /* Teal */
      background: rgba(45, 212, 191, 0.1);
      border-left: 2px solid var(--color-brand-accent-2);
    }

    .sidebar-item:hover {
      color: var(--color-brand-light);
      background: rgba(255, 255, 255, 0.05);
    }

    .sidebar-connector {
      position: absolute;
      left: 10px;
      top: 0;
      bottom: 0;
      border-left: 1px dashed rgba(255, 255, 255, 0.2);
    }

    .modal {
      margin-left: 300px;
      /* Offset for sidebar */
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 40px;
      box-sizing: border-box;
    }

    h2 {
      color: var(--color-brand-light);
      margin-bottom: 30px;
      text-transform: uppercase;
      letter-spacing: 2px;
      font-weight: 800;
      text-shadow: 0 0 20px rgba(56, 189, 248, 0.5);
      /* Blue Glow */
    }

    /* Grid Layout */
    .grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 30px;
      width: 100%;
      max-width: 1800px;
      transition: opacity 0.3s;
      justify-items: center;
      padding-bottom: 100px;
      /* Space for scroll */
    }

    /* Stack Container - The "Pile" */
    .stack {
      position: relative;
      width: 200px;
      height: 280px;
      perspective: 1200px;
      cursor: pointer;
      transition: transform 0.6s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.3s;
      z-index: 1;
    }

    /* The "fake" cards below the top card */
    .stack.piled::before,
    .stack.piled::after {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;

      /* Dark Cards */
      background: #1e293b;
      /* Slate-800 */
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);

      z-index: -1;
      transition: transform 0.3s;
    }

    /* Rotate the layers slightly to look messy */
    .stack.piled::before {
      transform: translate(2px, 3px) rotate(2deg);
    }

    .stack.piled::after {
      transform: translate(-3px, 4px) rotate(-1.5deg);
      z-index: -2;
    }

    /* Strategic Trails (Pathfinder) Styles */
    .node-active-trail {
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 100 !important;
      opacity: 1 !important;
      pointer-events: auto;
    }

    /* Glow Effects per Trail - Neon Pipeline */
    .legacy_rescue-glow {
      filter: drop-shadow(0 0 15px rgba(52, 152, 219, 0.9));
      border: 2px solid #3498db !important;
    }

    .safe_innovation-glow {
      filter: drop-shadow(0 0 15px rgba(46, 204, 113, 0.9));
      border: 2px solid #2ecc71 !important;
    }

    .systems_architect-glow {
      filter: drop-shadow(0 0 15px rgba(231, 76, 60, 0.9));
      border: 2px solid #e74c3c !important;
    }

    /* The "Blackout" Dimming logic */
    .node-dimmed {
      opacity: 0.2;
      filter: grayscale(100%) blur(2px);
      pointer-events: none;
      transition: all 0.5s ease;
    }

    /* FORCE THE BREAKOUT - High Specificity */
    #stackGrid.trail-view-active {
      display: flex !important;
      flex-wrap: wrap !important;
      grid-template-columns: none !important;
      justify-content: center !important;
      gap: 60px 40px !important;
      padding: 80px 20px !important;
    }

    /* MINI-CARD TRANSFORMATION */
    #stackGrid.trail-view-active .stack {
      width: 140px !important;
      /* Smaller footprint for map view */
      height: 190px !important;
      margin: 0 !important;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }

    /* CLEANUP: Remove repetitive 'ACTIVE PATH' labels seen in screenshot */
    #stackGrid.trail-view-active .active-path-label,
    #stackGrid.trail-view-active .corner {
      display: none !important;
    }

    /* THE NEON PIPELINE (Visual Connectors) */
    #stackGrid.trail-view-active .node-active-trail {
      position: relative;
      border-radius: 8px;
    }

    #stackGrid.trail-view-active .node-active-trail::after {
      content: "";
      position: absolute;
      right: -45px;
      /* Bridges the gap to the next flex item */
      top: 50%;
      width: 45px;
      height: 2px;
      background: var(--trail-color);
      box-shadow: 0 0 15px var(--trail-color);
      z-index: -1;
    }

    /* ZOOM ON HOVER: Maintains detail accessibility */
    #stackGrid.trail-view-active .stack:hover {
      transform: scale(1.6) translateY(-15px);
      z-index: 500 !important;
    }

    /* Active Path Label */
    .active-path-label {
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--trail-color, #fff);
      color: #000;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.7rem;
      font-weight: 800;
      text-transform: uppercase;
      box-shadow: 0 0 10px var(--trail-color, #fff);
      z-index: 200;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      animation: fadeIn 0.5s forwards 0.2s;
    }

    @keyframes fadeIn {
      to {
        opacity: 1;
      }
    }

    /* Sidebar Button Styling (Mission Control) */
    .trail-btn {
      width: 100%;
      padding: 15px;
      margin-bottom: 12px;
      background: #0f172a;
      /* Darker slate */
      border: 1px solid #334155;
      border-left: 4px solid transparent;
      color: #94a3b8;
      cursor: pointer;
      text-align: left;
      border-radius: 6px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-family: 'Inter', sans-serif;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .trail-btn:hover {
      background: #1e293b;
      color: white;
      border-color: #475569;
      transform: translateX(-2px);
    }

    .trail-btn.active {
      border-left-color: var(--trail-color, #fff);
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0) 100%);
      color: white;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    .trail-icon {
      font-size: 1.5rem;
      flex-shrink: 0;
    }

    .trail-text {
      display: flex;
      flex-direction: column;
    }

    .trail-title {
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 0.95rem;
      line-height: 1.2;
    }

    .trail-subtext {
      font-size: 0.75rem;
      opacity: 0.7;
      font-weight: 400;
      margin-top: 2px;
    }

    /* Space for scroll */
    .grid {
      padding-bottom: 100px;
    }

    .stack.piled:hover::after {
      transform: translate(-6px, 6px) rotate(-3deg);
    }

    /* Focused State */
    .stack.focused {
      position: fixed;
      top: 50%;
      left: calc(50% + 150px);
      transform: translate(-50%, -50%) scale(2.6);
      /* Reduced scale slightly as cards are big */
      z-index: 1000;
      /* Ensure it doesn't get clipped if it's too big */
      max-height: 90vh;
      max-width: calc(100vw - 340px);
    }

    .stack.faded {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transition: opacity 0.3s, visibility 0.3s;
    }

    /* Card Stylings */
    .card {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      transition: transform 0.6s;
      transform-style: preserve-3d;
      z-index: 2;
      /* Ensure top card is above the stack pile pseudo-elements */
    }

    .card.flip {
      transform: rotateY(180deg);
    }

    .card .front,
    .card .back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      border-radius: 12px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px;
      box-sizing: border-box;

      /* Glassmorphism Base */
      background: rgba(30, 41, 59, 0.7);
      /* Dark Glass */
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
    }

    /* Playing Card "Face" Pattern (Simplified) */
    .card .front {
      /* Front Specifics */
      background: rgba(15, 23, 42, 0.85);
      /* Slightly darker/more opaque for readability */
      padding: 24px;
      border: 1px solid rgba(56, 189, 248, 0.2);
      /* Subtle Blue Border */
    }

    /* Corners for Rank/Suit */
    .corner {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      line-height: 1;
      font-weight: bold;
      font-size: 1.2rem;
      padding: 8px;
      color: var(--color-brand-light);
      /* Default color */
    }

    .top-left {
      top: 5px;
      left: 5px;
    }

    .bottom-right {
      bottom: 5px;
      right: 5px;
      transform: rotate(180deg);
    }

    .card-content-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      padding: 0 10px;
      /* Reduced side padding */
      width: 100%;
    }

    .card-title {
      font-family: 'Courier New', Courier, monospace;
      /* Kept for "Nuts & Bolts" label feel */
      font-weight: 900;
      letter-spacing: 1px;
      font-size: 0.85rem;
      color: var(--color-brand-accent-1);
      /* Blue for titles */
      text-shadow: 0 0 10px rgba(56, 189, 248, 0.3);
      margin-top: 10px;
    }

    .card .back {
      transform: rotateY(180deg);

      /* Back Specifics - Waal Bridge Dark Glass */
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(168, 85, 247, 0.3);
      /* Purple Border for back */
      box-shadow: 0 0 15px rgba(168, 85, 247, 0.15);
      /* Purple Glow */

      color: var(--color-brand-light);
      justify-content: space-between;
      padding: 20px;
    }

    /* New Back Styles - FlipCardApp Design */
    /* New Back Styles - FlipCardApp Design */
    /* Sizes are reduced to compensate for 2.6x scale when focused */
    .card-description-input {
      font-size: 0.8rem;
      text-align: left;
      flex-grow: 1;
      width: 100%;
      padding: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 4px;

      /* Dark Input Style */
      background-color: rgba(0, 0, 0, 0.3);
      color: var(--color-brand-light);
      font-family: 'Inter', sans-serif;

      resize: none;
      min-height: 80px;
      box-sizing: border-box;
      margin-top: 4px;
      outline: none;
      line-height: 1.4;
    }

    .card-description-input:focus {
      border-color: var(--color-brand-accent-1);
    }

    .checkbox-container {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin: 4px 0;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 500;
      color: #94a3b8;
      /* Slate-400 */
    }

    .checkbox-label input[type="checkbox"] {
      width: 12px;
      height: 12px;
      cursor: pointer;
      accent-color: var(--color-brand-accent-2);
      /* Teal Checkbox */
    }

    /* Buttons - Sizes reduced to compensate for 2.6x scale */
    .explore-btn {
      padding: 6px 16px;
      border: none;
      border-radius: 4px;

      /* Gradient Button */
      background: linear-gradient(90deg, var(--color-brand-accent-1), var(--color-brand-accent-2));
      color: var(--color-brand-midnight);

      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.75rem;
      margin-top: 4px;
      align-self: center;
      box-shadow: 0 2px 5px rgba(56, 189, 248, 0.3);
    }

    .explore-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(56, 189, 248, 0.5);
      filter: brightness(1.1);
    }

    .explore-btn:disabled {
      background: #475569;
      /* Slate-600 */
      color: #94a3b8;
      cursor: not-allowed;
      opacity: 0.6;
      box-shadow: none;
      transform: none;
    }

    /* Back Button */
    .navigation-controls {
      position: sticky;
      top: 20px;
      /* Centered in flex column modal */
      align-self: center;
      display: flex;
      gap: 20px;
      z-index: 2000;
      pointer-events: none;
      /* Let clicks pass through empty space */
      margin-bottom: 20px;
      /* Space between buttons and cards */
    }

    .back-button {
      display: none;
      /* Toggled via JS */
      padding: 10px 24px;

      /* Waal Bridge Gradient */
      background: linear-gradient(90deg, var(--color-brand-accent-1), var(--color-brand-accent-2));
      color: var(--color-brand-midnight);

      border: none;
      border-radius: 9999px;
      /* Pill shape */
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      box-shadow: 0 4px 15px rgba(56, 189, 248, 0.3);
      pointer-events: auto;
      /* Re-enable clicks on buttons */
      transition: all 0.3s;
    }

    .back-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(56, 189, 248, 0.5);
      filter: brightness(1.1);
    }

    #upLevelBtn {
      background: linear-gradient(90deg, var(--color-brand-accent-3), #d946ef);
      /* Purple to Pink */
      box-shadow: 0 4px 15px rgba(168, 85, 247, 0.3);
    }

    #upLevelBtn:hover {
      box-shadow: 0 6px 20px rgba(168, 85, 247, 0.5);
    }

    /* Popup */
    .diagram-popup {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(2, 6, 23, 0.95);
      /* Midnight almost opaque */
      z-index: 3000 !important;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      backdrop-filter: blur(5px);
    }

    .diagram-popup img {
      max-width: 90%;
      max-height: 80vh;
      border-radius: 8px;
      box-shadow: 0 0 50px rgba(56, 189, 248, 0.3);
      /* Blue Glow */
      border: 1px solid rgba(56, 189, 248, 0.2);
    }

    .close-btn {
      color: var(--color-brand-light);
      font-size: 3rem;
      position: absolute;
      top: 30px;
      right: 40px;
      cursor: pointer;
      transition: color 0.2s;
    }

    .close-btn:hover {
      color: var(--color-brand-accent-3);
      /* Purple hover */
    }

    .caption {
      color: var(--color-brand-light);
      margin-top: 20px;
      font-size: 1.2rem;
      font-weight: 300;
    }

    /* Pagination */
    .pagination {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 40px;
      margin-bottom: 40px;
    }

    .page-btn {
      padding: 10px 15px;
      background: rgba(30, 41, 59, 0.5);
      color: #94a3b8;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
    }

    .page-btn.active {
      background: var(--color-brand-accent-1);
      color: var(--color-brand-midnight);
      border-color: var(--color-brand-accent-1);
      box-shadow: 0 0 10px rgba(56, 189, 248, 0.4);
    }

    .page-btn:hover:not(.active) {
      background: rgba(56, 189, 248, 0.2);
      color: white;
    }

    .child-indicator {
      position: absolute;
      bottom: 15px;
      left: 15px;
      width: 12px;
      height: 12px;
      background-color: var(--color-brand-accent-2);
      /* Teal */
      border-radius: 50%;
      z-index: 10;
      box-shadow: 0 0 8px rgba(45, 212, 191, 0.6);
      border: 1px solid white;
    }

    .flip-button {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 30px;
      height: 30px;
      background-color: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      font-size: 18px;
      color: var(--color-brand-light);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      user-select: none;
      display: none;
      transition: all 0.2s;
    }

    /* Ensure flip button on back is visible */
    .card .back .flip-button {
      display: flex;
      background-color: rgba(255, 255, 255, 0.1);
    }

    .stack.focused .flip-button {
      display: flex;
    }

    .flip-button:hover {
      background-color: var(--color-brand-accent-1);
      color: var(--color-brand-midnight);
      transform: scale(1.1);
      border-color: var(--color-brand-accent-1);
    }

    /* --- Network View Styles (D3) --- */
    #networkContainer {
      display: none;
      /* Hidden by default */
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #0f172a;
      /* Slate 900 - Dark opaque background */
      z-index: 9999;
      /* Topmost layer */
      overflow: hidden;
    }

    .network-node rect {
      fill: rgba(30, 41, 59, 0.9);
      stroke: var(--trail-color, #38bdf8);
      stroke-width: 2px;
      rx: 8px;
      /* Rounded corners */
      ry: 8px;
      filter: drop-shadow(0 0 8px var(--trail-color, #38bdf8));
      transition: stroke-width 0.2s, fill 0.2s;
      cursor: grab;
    }

    .network-node:active rect {
      cursor: grabbing;
    }

    .network-node:hover rect {
      fill: var(--trail-color, #38bdf8);
      stroke: white;
      stroke-width: 3px;
    }

    .network-node text {
      font-family: 'Inter', sans-serif;
      font-size: 10px;
      fill: white;
      text-anchor: middle;
      pointer-events: none;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      user-select: none;
    }

    .network-link {
      fill: none;
      stroke: #94a3b8;
      /* Default Slate 400 */
      stroke-width: 1.5px;
      opacity: 0.6;
      transition: stroke-width 0.2s;
    }

    .network-link.high-tension-link {
      stroke: #ef4444 !important;
      /* Force RED */
      stroke-width: 3px !important;
      stroke-dasharray: none !important;
      filter: drop-shadow(0 0 5px #ef4444) !important;
      /* RED Glow */
      opacity: 1 !important;
      animation: pulse-tension 2s infinite;
    }

    @keyframes pulse-tension {
      0% {
        stroke-opacity: 0.8;
        stroke-width: 3px;
      }

      50% {
        stroke-opacity: 1;
        stroke-width: 4px;
      }

      100% {
        stroke-opacity: 0.8;
        stroke-width: 3px;
      }
    }

    /* Seed Filter Checkboxes */
    .seed-filter-container {
      display: flex;
      flex-direction: column;
      gap: 5px;
      background: rgba(15, 23, 42, 0.95);
      padding: 10px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      margin-bottom: 5px;
    }

    .seed-checkbox-label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      color: #cbd5e1;
      cursor: pointer;
      user-select: none;
    }

    .seed-checkbox-label input {
      cursor: pointer;
    }

    /* Control Buttons */
    .network-controls {
      position: absolute;
      bottom: 30px;
      right: 30px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 10001;
    }

    .network-btn {
      width: 40px;
      height: 40px;
      background: rgba(30, 41, 59, 0.9);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      font-size: 18px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .network-btn:hover {
      background: var(--trail-color);
      color: black;
      border-color: white;
    }

    .close-network-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 10002;
      padding: 10px 20px;
      background: rgba(220, 38, 38, 0.9);
      /* Red */
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
      transition: all 0.2s;
    }

    .close-network-btn:hover {
      background: rgba(185, 28, 28, 1);
      transform: scale(1.05);
    }

    .network-link.active-link {
      stroke: var(--trail-color, #38bdf8);
      stroke-width: 3px;
      filter: drop-shadow(0 0 5px var(--trail-color, #38bdf8));
    }

    /* Tooltip/Context Menu for Network */
    .network-tooltip {
      position: absolute;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid var(--trail-color);
      padding: 10px;
      border-radius: 8px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
      z-index: 5000;
      max-width: 200px;
    }
  </style>

</head>

<body>

  <div id="pathSidebar">
    <!-- Back Navigation -->
    <a href="index.html"
      class="block px-5 py-4 mb-4 border-b border-white/10 text-brand-accent-1 hover:text-white hover:bg-white/5 transition-all group no-underline">
      <div class="flex items-center gap-2">
        <svg class="w-4 h-4 group-hover:-translate-x-1 transition-transform" fill="none" viewBox="0 0 24 24"
          stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
        </svg>
        <span class="font-bold text-sm tracking-wide uppercase">Back to Portfolio</span>
      </div>
    </a>

    <!-- Raw Data Viewer -->
    <a href="raw_data.html" target="_blank"
      class="block px-5 py-4 mb-4 border-b border-white/10 text-brand-accent-1 hover:text-white hover:bg-white/5 transition-all group no-underline">
      <div class="flex items-center gap-2">
        <span class="font-bold text-sm tracking-wide uppercase">Raw Data Viewer</span>
      </div>
    </a>



    <h3>Current Path</h3>
    <div id="pathList"></div>
  </div>

  <!-- Right Sidebar for Strategic Trails -->
  <div id="strategicSidebar">
    <h3>Strategic Trails</h3>
    <div id="trailsContainer"></div>
    <button id="resetTrailsBtn" class="trail-btn"
      style="width: 100%; text-align: center; background: #333; color: white; display: none;">
      Reset View
    </button>

    <!-- Skill Match / Recruiter Search -->
    <div id="skillMatchContainer"
      style="margin-top: 40px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 20px;">
      <h3>Skill Match</h3>
      <textarea id="skillInput" placeholder="Paste Job Spec / Keywords..."
        style="width: 100%; height: 80px; background: rgba(0,0,0,0.3); color: #e2e8f0; border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; padding: 10px; font-family: 'Inter', sans-serif; font-size: 0.85rem; resize: vertical; box-sizing: border-box;"></textarea>
      <button onclick="runSkillMatch()"
        style="width: 100%; margin-top: 10px; padding: 10px; background: linear-gradient(135deg, var(--color-brand-accent-2) 0%, var(--color-brand-accent-1) 100%); color: #0f172a; border: none; border-radius: 4px; font-weight: bold; cursor: pointer; text-transform: uppercase; font-size: 0.8rem; letter-spacing: 0.05em; transition: opacity 0.2s;">
        Find Evidence
      </button>
      <!-- Results open in popup -->
    </div>
  </div>

  <div class="modal">
    <div class="navigation-controls" id="navControls">
      <button class="back-button" id="backButton">Back to Grid</button>
      <button class="back-button" id="upLevelBtn" style="background-color: #27ae60;">Up One Level</button>
    </div>

    <div class="grid" id="stackGrid"></div>
    <div id="networkContainer"></div>

    <div class="pagination" id="pagination"></div>
  </div>

  <div class="diagram-popup" id="diagramPopup">
    <span class="close-btn" onclick="closeDiagram()">× Close</span>
    <img id="diagramImage" src="" alt="Diagram">
    <div id="diagramCaption"></div>
  </div>

  <div class="diagram-popup" id="mediaSelectionPopup" style="background: rgba(0,0,0,0.9);">
    <span class="close-btn" onclick="closeMediaSelection()">× Close</span>
    <h2 style="color: white; margin-bottom: 20px;">Select an Image</h2>
    <div id="mediaSelectionContainer" style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;"></div>
  </div>

  <div class="diagram-popup" id="jsonErrorModal" style="background: rgba(50, 0, 0, 0.95); z-index: 9999;">
    <div
      style="text-align: center; max-width: 600px; padding: 40px; border: 2px solid #ef4444; border-radius: 16px; background: #1e293b; color: white; display: flex; flex-direction: column; gap: 20px; box-shadow: 0 0 50px rgba(239, 68, 68, 0.5);">
      <div style="font-size: 4rem; color: #ef4444;">⚠️</div>
      <h2 style="color: #ef4444; margin: 0; font-size: 2rem;">Data Loading Error</h2>
      <p style="font-size: 1.1rem; line-height: 1.6; color: #cbd5e1;">There was a problem loading the project data. This
        is usually caused by a syntax error in <strong>cards.json</strong> or <strong>relationships.json</strong>.</p>

      <div id="jsonErrorMessage"
        style="background: #0f172a; padding: 15px; border-radius: 8px; font-family: monospace; text-align: left; color: #fca5a5; font-size: 0.9rem; overflow-x: auto; border: 1px solid #7f1d1d;">
        Error details...
      </div>

      <button onclick="location.reload()"
        style="padding: 12px 24px; background: #ef4444; color: white; border: none; border-radius: 8px; font-weight: bold; font-size: 1rem; cursor: pointer; transition: all 0.2s; text-transform: uppercase; letter-spacing: 1px;">
        Reload App
      </button>
    </div>
  </div>

  <div class="diagram-popup" id="skillMatchPopup" style="background: rgba(15, 23, 42, 0.95);">
    <span class="close-btn" onclick="closeSkillMatch()">× Close</span>
    <h2 style="color: var(--color-brand-accent-2); margin-top: 20px; margin-bottom: 20px;">Skill Match Results</h2>
    <div id="skillMatchResultsList" style="
        width: 80%; 
        max-width: 600px; 
        max-height: 70vh; 
        overflow-y: auto; 
        background: rgba(255,255,255,0.05); 
        border-radius: 8px; 
        padding: 20px; 
        border: 1px solid rgba(255,255,255,0.1);
        display: flex; 
        flex-direction: column; 
        gap: 10px;">
    </div>
  </div>

  <script>
    let cards = {};
    let relationships = [];
    let currentStackId = null;
    let breadcrumbs = [];

    // wrapper to fetch and check json
    const fetchJson = (url) => {
      return fetch(url + '?t=' + Date.now())
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status} for ${url}`);
          }
          return response.json();
        })
        .catch(err => {
          throw new Error(`Failed to load ${url}: ${err.message}`);
        });
    };

    // Load Data
    let trailsConfig = [];

    Promise.all([
      fetchJson('cards.json'),
      fetchJson('relationships.json'),
      fetchJson('pathfinder_config.json').catch(e => { console.warn("No trails config found"); return { trails: [] }; })
    ]).then(([cardsData, relationshipsData, configData]) => {
      // Handle wrappers if present (user provided files have 'cards' and 'relationships' keys)
      const cList = cardsData.cards || cardsData;
      const rList = relationshipsData.relationships || relationshipsData;

      cList.forEach(c => cards[c.id] = c);
      relationships = rList;

      if (configData && configData.trails) {
        trailsConfig = configData.trails;
        initTrailsUI();
      }

      init();
    }).catch(err => {
      console.error("Critical Data Error:", err);
      const modal = document.getElementById('jsonErrorModal');
      const msg = document.getElementById('jsonErrorMessage');
      if (modal && msg) {
        msg.textContent = err.message;
        modal.style.display = 'flex'; // Use flex to center with existing class
      }
    });

    function init() {
      // Find top-level stacks and assign Suit/Rank 
      const suits = ['♠', '♥', '♣', '♦'];
      // User request: "They can all be aces"
      const rank = 'A';

      const allCards = Object.values(cards);
      allCards.forEach((c, index) => {
        const suit = suits[index % suits.length];
        c.suit = suit;
        c.rank = rank;
        c.color = (suit === '♥' || suit === '♦') ? '#e74c3c' : '#2c3e50';
      });

      renderRoot();
    }

    // Navigation
    function renderRoot() {
      currentStackId = null;
      breadcrumbs = [];
      updateBreadcrumbs();

      const rootStacks = Object.values(cards).filter(c => c.type === 'stack');
      // Sort by ID to ensure order if needed, assuming numeric prefixes in IDs like '001_'
      rootStacks.sort((a, b) => a.id.localeCompare(b.id));
      renderGrid(rootStacks);
    }

    function renderGrid(cardList) {
      const grid = document.getElementById('stackGrid');
      grid.innerHTML = '';

      cardList.forEach(card => {
        const cardEl = createCardElement(card);
        grid.appendChild(cardEl);
      });
    }

    function createCardElement(card) {
      const el = document.createElement('div');

      // Helper functions for relationships
      const getSource = (r) => r.source || r.from;
      const getTarget = (r) => r.target || r.to;

      el.id = card.id; // Critical for Pathfinder
      el.className = 'stack'; // Using 'stack' class for main grid items for now

      const hasChildren = relationships.some(r => (r.source || r.from) === card.id && (r.type === 'contains' || r.type === 'leads_to'));
      const indicatorHtml = hasChildren ? '<div class="child-indicator" title="Click to view more details"></div>' : '';

      el.className = 'stack'; // Base class
      if (hasChildren) {
        el.classList.add('piled');
      }

      // Determine contents for back of card
      let displayContent = "";
      if (card.description && card.description.trim()) {
        displayContent = card.description;
      } else if (card.details && card.details.trim()) {
        displayContent = card.details;
      } else {
        displayContent = "(No description available)";
      }

      // Image Logic: Prefer displayImages.front.url -> card_image -> boltandnut.png
      let frontImage = null;
      if (card.displayImages && card.displayImages.front && card.displayImages.front.url) {
        frontImage = card.displayImages.front.url;
      } else if (card.card_image) {
        frontImage = card.card_image;
      }

      // Back image logic
      const imageSrc = card.card_image || "boltandnut.png";

      // Determine media availability
      let hasPdf = false;
      let hasGraphic = false;
      let hasWeb = false;
      let hasVideo = false;

      if (card.media && Array.isArray(card.media)) {
        hasPdf = card.media.some(file => file.toLowerCase().endsWith('.pdf'));
        hasGraphic = card.media.some(file => {
          const f = file.toLowerCase();
          return f.endsWith('.png') || f.endsWith('.jpg') || f.endsWith('.jpeg') || f.endsWith('.gif') || f.endsWith('.webp');
        });
      }

      // Check for new fields
      if (card.web && card.web.trim().length > 0) {
        hasWeb = true;
      }
      if (card.video && card.video.trim().length > 0) {
        hasVideo = true;
      }

      // Auto-enable view button if content exists
      const viewDisabled = (!hasPdf && !hasGraphic && !hasWeb && !hasVideo) ? 'disabled' : '';

      el.innerHTML = `
        <div class="card">
            <div class="front" style="color: ${card.color || 'black'}; background-color: ${card.frontBackgroundColor || '#fafafa'};">
                <div class="flip-button" title="Flip Card">⟳</div>
                ${indicatorHtml}
                <div class="corner top-left">
                    <div class="suit"><img src="boltandnut.png" alt="suit" style="width: 24px; height: auto; filter: sepia(1) hue-rotate(90deg) saturate(3) brightness(0.9);"></div>
                </div>
                
                <div class="card-content-wrapper">
                   ${frontImage ? `<div class="card-image-custom"><img src="${frontImage}" alt="Card Image" style="max-width: 100%; height: 65px; object-fit: contain; margin-bottom: 10px;"></div>` : ''}
                   <div class="card-title">${card.title}</div>
                </div>

                <div class="corner bottom-right">
                    <div class="suit"><img src="boltandnut.png" alt="suit" style="width: 24px; height: auto; filter: sepia(1) hue-rotate(90deg) saturate(3) brightness(0.9);"></div>
                </div>
            </div>
            <div class="back">
                <div class="flip-button" title="Flip Card">⟳</div>
                
                <textarea class="card-description-input" readonly>${card.title}\n\n${displayContent}</textarea>
                
                <div class="checkbox-container">
                    <label class="checkbox-label">
                        <input type="checkbox" class="pdf-checkbox" name="pdf" ${hasPdf ? 'checked' : ''} disabled>
                        <span>PDF</span>
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" class="graphic-checkbox" name="graphic" ${hasGraphic ? 'checked' : ''} disabled>
                        <span>Graphic</span>
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" class="web-checkbox" name="web" ${hasWeb ? 'checked' : ''} disabled>
                        <span>Web</span>
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" class="video-checkbox" name="video" ${hasVideo ? 'checked' : ''} disabled>
                        <span>Video</span>
                    </label>
                </div>
                
                <button class="explore-btn" ${viewDisabled}>View</button>
            </div>
        </div>
      `;

      // Flip button Logic
      const cardInner = el.querySelector('.card');
      const flipButtons = el.querySelectorAll('.flip-button');
      flipButtons.forEach(btn => {
        btn.onclick = (e) => {
          e.stopPropagation(); // Stop bubbling to card click
          cardInner.classList.toggle('flip');
        };
      });

      // Checkbox validation logic for View button removed as checkboxes are now readonly.
      // View button state is set initially based on content.
      const pdfCheckbox = el.querySelector('.pdf-checkbox');
      const graphicCheckbox = el.querySelector('.graphic-checkbox');

      // Explore Button Logic
      const exploreBtn = el.querySelector('.explore-btn');
      exploreBtn.onclick = (e) => {
        e.stopPropagation();

        // 1. Aggregate all media types
        let allMedia = [];

        // PDF / Images from card.media
        if (card.media) {
          let mediaList = [];
          if (Array.isArray(card.media)) {
            mediaList = card.media.flatMap(m => m.split(',').map(s => s.trim()));
          } else if (typeof card.media === 'string') {
            mediaList = card.media.split(',').map(s => s.trim());
          }

          mediaList.forEach(m => {
            let cleanPath = m.trim();
            // Remove existing prefixes if present (for robustness during migration)
            cleanPath = cleanPath.replace(/^(pdf|images)[\\/]/i, '');

            const lower = cleanPath.toLowerCase();
            let type = 'image';
            let finalPath = cleanPath;

            if (lower.endsWith('.pdf')) {
              type = 'pdf';
              finalPath = 'pdf/' + cleanPath;
            } else {
              // Assume image
              finalPath = 'images/' + cleanPath;
            }

            allMedia.push({ type: type, value: finalPath, title: cleanPath });
          });
        }

        // Web Link
        if (card.web && card.web.trim().length > 0) {
          const links = card.web.split(',');
          links.forEach(link => {
            const url = link.trim();
            if (url) {
              allMedia.push({ type: 'web', value: url, title: 'Web Link' });
            }
          });
        }

        // Video
        if (card.video && card.video.trim().length > 0) {
          const videos = card.video.split(',');
          videos.forEach(v => {
            // Assuming video is in 'Videos/' subdirectory if it doesn't have a path
            let vPath = v.trim();

            // Clean up path separators
            vPath = vPath.replace(/\\/g, '/');
            if (vPath.startsWith('/')) vPath = vPath.substring(1);

            if (vPath && !vPath.includes('/')) {
              vPath = 'Videos/' + vPath;
            }
            if (vPath) {
              allMedia.push({ type: 'video', value: vPath, title: 'Video' });
            }
          });
        }

        // 2. Decide Action
        if (allMedia.length > 0) {
          if (allMedia.length === 1) {
            showMedia(allMedia[0]);
          } else {
            showMediaSelection(allMedia);
          }
          return;
        }

        // Fallback to legacy relationship-based media (preserve existing logic)
        const mediaRels = relationships.filter(r => getSource(r) === card.id && r.type === 'show_media');

        if (mediaRels.length > 0) {
          const targetId = getTarget(mediaRels[0]);
          if (cards[targetId]) {
            // For legacy, we just assume it's an image/pdf on the target card
            // We'll wrap it in our new structure to be safe, or showMedia needs to handle raw cards too?
            // The existing showMedia took a card. Let's make showMedia handle both for backward compat or update this.
            // Simplest: construct a mock item
            let mSrc = (typeof cards[targetId].media === 'string') ? cards[targetId].media : cards[targetId].card_image;
            if (Array.isArray(cards[targetId].media)) mSrc = cards[targetId].media[0];

            let type = 'image';
            if (mSrc && mSrc.toLowerCase().endsWith('.pdf')) type = 'pdf';

            showMedia({ type: type, value: mSrc, title: cards[targetId].title });
          }
        } else {
          console.log("No media to explore for this card.");
        }
      };

      // Card Grid Click Logic (Focus Interaction)
      el.onclick = (e) => {
        // Ignore clicks on buttons or interactive elements
        if (e.target.closest('button') || e.target.closest('.flip-button') || e.target.closest('.explore-btn') || e.target.closest('.child-indicator')) return;

        if (el.classList.contains('focused')) {
          // "Currently if you click on anywhere other than the button you display the childen of the big card."
          // So clicking a focused card should drill down.

          const hasKids = relationships.some(r => (r.source || r.from) === card.id && (r.type === 'contains' || r.type === 'leads_to'));
          if (hasKids) {
            navigateTo(card);
          } else {
            // Leaf node: fallback to flip toggle if no children
            const cardInner = el.querySelector('.card');
            cardInner.classList.toggle('flip');
          }
        } else {
          // Not focused, just focus
          focusStack(el);
        }
      };

      return el;
    }

    function focusStack(stackEl) {
      if (stackEl.classList.contains('focused')) {
        return;
      }

      const grid = document.getElementById('stackGrid');
      // Fade out others
      Array.from(grid.children).forEach(child => {
        if (child !== stackEl) child.classList.add('faded');
      });

      stackEl.classList.add('focused');
      document.getElementById('backButton').style.display = 'block';
      document.querySelector('.navigation-controls').style.display = 'flex';
    }

    function clearFocus() {
      const grid = document.getElementById('stackGrid');
      if (grid) {
        Array.from(grid.children).forEach(child => {
          child.classList.remove('faded');
          child.classList.remove('focused');
          const card = child.querySelector('.card');
          if (card) card.classList.remove('flip');
        });
      }
    }

    document.getElementById('backButton').onclick = () => {
      clearFocus();

      // If we are drilled down, "Back to Grid" means "Home" / "Top Level"
      if (breadcrumbs.length > 0) {
        renderRoot();
        // renderRoot handles breadcrumbs reset and UI updates
        return;
      }

      // If we are at root (breadcrumbs.length === 0), just unfocus (which we did above)
      document.getElementById('backButton').style.display = 'none';
      document.querySelector('.navigation-controls').style.display = 'none';
    };

    function navigateTo(parentCard, specificChild = null) {
      // No need to click backButton, it resets breadcrumbs! 
      // Just proceed to render new level.

      // Update State
      currentStackId = parentCard.id;
      breadcrumbs.push(parentCard);
      updateBreadcrumbs();

      const grid = document.getElementById('stackGrid');
      grid.innerHTML = '';

      const getSource = (r) => r.source || r.from;
      const getTarget = (r) => r.target || r.to;

      let itemsToShow = [];
      if (specificChild) {
        itemsToShow = [specificChild];
      } else {
        const childrenIds = relationships
          .filter(r => getSource(r) === parentCard.id && r.type === 'contains')
          .map(r => getTarget(r));
        itemsToShow = childrenIds.map(id => cards[id]);
      }

      // If no children found for a stack
      if (itemsToShow.length === 0) {
        grid.innerHTML = '<div style="color:white; text-align:center; width:100%;">No items found in this category.</div>';
        return;
      }

      itemsToShow.forEach(c => {
        if (!c) return;
        grid.appendChild(createCardElement(c));
      });
    }


    function updateBreadcrumbs() {
      // Sidebar Update
      updateSidebar();

      // Top Breadcrumbs (Home > ...) removed as per user request (replaced by sidebar)
      /*
      let bcContainer = document.getElementById('breadcrumbs');
      if (!bcContainer) {
         // ...
      }
      */
      // Ensure existing specific breadcrumb container is removed if it exists from previous renders
      let bcContainer = document.getElementById('breadcrumbs');
      if (bcContainer) {
        bcContainer.style.display = 'none';
      }

      const upBtn = document.getElementById('upLevelBtn');
      if (breadcrumbs.length > 0) {
        upBtn.style.display = 'block';
        upBtn.onclick = () => {
          // If a card is currently focused, unfocus it first
          const focusedCard = document.querySelector('.focused');
          if (focusedCard) {
            clearFocus();
            focusedCard.classList.remove('focused');
            // If the user wants "Up One Level" to effectively mean "Back to the grid I was just looking at", 
            // then we stop here because we just revealed the grid.
            // But if "Up One Level" means "Go to Parent Stack", we should proceed?
            // Current behavior: Button says "Up One Level". 
            // If I am zoomed in on a card, "Up" is "Zoom Out back to grid". 
            return;
          }

          if (breadcrumbs.length === 1) {
            renderRoot();
          } else {
            jumpToCrumb(breadcrumbs.length - 2);
          }
        };
      }

      const navControls = document.querySelector('.navigation-controls');
      if (navControls) {
        // Show controls if we are deep in hierarchy OR if a card is focused (handled by focusStack usually, but nice to be robust)
        // User wants buttons visible "all the time appart from the top level stack card view"
        if (breadcrumbs.length > 0) {
          navControls.style.display = 'flex';
          document.getElementById('backButton').style.display = 'block';
        } else {
          // At root. Only show if a card is focused (handled by focusStack). 
          // If no card is focused, hide.
          if (!document.querySelector('.focused')) {
            navControls.style.display = 'none';
          }
        }
      }
    }

    function updateSidebar() {
      const container = document.getElementById('pathList');
      if (!container) return;
      container.innerHTML = '';

      // Build path array: Home + breadcrumbs
      const path = [{ title: 'Home', id: 'root' }, ...breadcrumbs];

      path.forEach((item, index) => {
        const div = document.createElement('div');
        div.className = 'sidebar-item';

        // Indentation
        div.style.paddingLeft = (20 + (index * 15)) + 'px';

        // Current Node Highlight and Trail Color
        if (index === path.length - 1) {
          div.classList.add('current-node');
        }

        // Apply Trail Color if active
        if (activeTrailId) {
          const config = trailsConfig.find(t => t.id === activeTrailId);
          if (config) {
            div.style.color = config.color;
            div.style.textShadow = `0 0 5px ${config.color}`;
          }
        } else {
          div.style.color = '';
          div.style.textShadow = '';
        }

        // Reduced interactivity significantly as per user request "Sidebar is readonly"
        // No click handlers here.

        div.textContent = item.title || item.id;
        container.appendChild(div);
      });

      // Auto-scroll to bottom of sidebar
      const sidebar = document.getElementById('pathSidebar');
      sidebar.scrollTop = sidebar.scrollHeight;
    }


    function jumpToCrumb(index) {
      // targetCard is the card at index (0-based in breadcrumbs)
      const targetCard = breadcrumbs[index];

      // Slice breadcrumbs to include up to index (so we keep 0..index)
      // correct slice is (0, index + 1)
      breadcrumbs = breadcrumbs.slice(0, index + 1);
      currentStackId = targetCard.id;

      // Clear focus if any
      const grid = document.getElementById('stackGrid');
      if (grid) {
        Array.from(grid.children).forEach(child => child.classList.remove('focused', 'faded'));
      }
      document.getElementById('backButton').style.display = 'none';

      updateBreadcrumbs();

      // Render content
      const gridEl = document.getElementById('stackGrid');
      gridEl.innerHTML = '';

      const getSource = (r) => r.source || r.from;
      const getTarget = (r) => r.target || r.to;

      const childrenIds = relationships
        .filter(r => getSource(r) === targetCard.id && r.type === 'contains')
        .map(r => getTarget(r));

      let itemsToShow = childrenIds.map(id => cards[id]);

      if (itemsToShow.length === 0) {
        gridEl.innerHTML = '<div style="color:white; text-align:center;">No items found.</div>';
      } else {
        itemsToShow.forEach(c => {
          if (c) gridEl.appendChild(createCardElement(c));
        });
      }
    }
    window.renderRoot = renderRoot;

    function showMedia(item) {
      console.log("showMedia called with:", item);

      // Handle Web
      if (item.type === 'web') {
        window.open(item.value, '_blank');
        return;
      }

      // Detect media type
      const popupContent = document.getElementById('diagramPopup');
      // Clear existing content except caption/close
      const imgEl = document.getElementById('diagramImage');
      const captionEl = document.getElementById('diagramCaption');

      // Helper to reset popup
      const resetPopup = () => {
        imgEl.style.display = 'none';
        const existingIframe = document.getElementById('pdfFrame');
        if (existingIframe) existingIframe.remove();
        const existingVideo = document.getElementById('videoPlayer');
        if (existingVideo) existingVideo.remove();
        const existingErr = document.getElementById('imgError');
        if (existingErr) existingErr.remove();
      };
      resetPopup();

      if (item.type === 'pdf') {
        console.log("Displaying as PDF");

        const iframe = document.createElement('iframe');
        iframe.id = 'pdfFrame';
        iframe.src = item.value;
        iframe.style.width = '90%';
        iframe.style.height = '80vh';
        iframe.style.border = 'none';
        iframe.style.borderRadius = '8px';
        iframe.style.boxShadow = '0 0 50px rgba(0, 0, 0, 0.5)';

        popupContent.insertBefore(iframe, captionEl);
      } else if (item.type === 'video') {
        console.log("Displaying as Video");

        const video = document.createElement('video');
        video.id = 'videoPlayer';
        video.controls = true;
        video.autoplay = true;
        video.style.width = '90%';
        video.style.maxHeight = '80vh';
        video.style.borderRadius = '8px';
        video.style.boxShadow = '0 0 50px rgba(0, 0, 0, 0.5)';

        const source = document.createElement('source');
        source.src = item.value;
        source.type = 'video/mp4';
        video.appendChild(source);

        popupContent.insertBefore(video, captionEl);
      } else {
        console.log("Displaying as Image");
        imgEl.style.display = 'block';
        imgEl.src = item.value || '';
        imgEl.onerror = function () {
          this.style.display = 'none';
          const errDiv = document.createElement('div');
          errDiv.id = 'imgError';
          errDiv.style.color = 'white';
          errDiv.style.textAlign = 'center';
          errDiv.innerHTML = '<h3>Image Not Found</h3><p>' + (item.value || 'No source provided') + '</p>';
          popupContent.insertBefore(errDiv, captionEl);
        };
      }

      captionEl.textContent = item.title || '';
      popupContent.style.display = 'flex';
    }

    function showMediaSelection(items) {
      const container = document.getElementById('mediaSelectionContainer');
      container.innerHTML = ''; // Clear previous

      items.forEach(item => {
        const btn = document.createElement('div');
        btn.style.cssText = `
                width: 150px; 
                height: 150px; 
                border: 2px solid white; 
                border-radius: 8px; 
                overflow: hidden; 
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                background: #333;
                flex-direction: column;
            `;

        let previewHtml = '';
        if (item.type === 'pdf') {
          previewHtml = `<div style="width: 100%; height: 100px; display: flex; align-items: center; justify-content: center; background: #e74c3c; color: white; font-weight: bold; font-size: 24px;">PDF</div>`;
        } else if (item.type === 'video') {
          previewHtml = `<div style="width: 100%; height: 100px; display: flex; align-items: center; justify-content: center; background: #8e44ad; color: white; font-weight: bold; font-size: 24px;">▶</div>`;
        } else if (item.type === 'web') {
          previewHtml = `<div style="width: 100%; height: 100px; display: flex; align-items: center; justify-content: center; background: #2980b9; color: white; font-weight: bold; font-size: 24px;">WWW</div>`;
        } else {
          // Image
          previewHtml = `<img src="${item.value}" style="width: 100%; height: 100px; object-fit: cover; margin-bottom: 5px;">`;
        }

        btn.innerHTML = `
                ${previewHtml}
                <span style="color: white; font-size: 0.8rem; word-break: break-all; padding: 2px; text-transform: capitalize; text-align: center;">${item.title || item.value}</span>
            `;

        btn.onclick = () => {
          closeMediaSelection();
          showMedia(item);
        };

        container.appendChild(btn);
      });

      document.getElementById('mediaSelectionPopup').style.display = 'flex';
    }

    function closeMediaSelection() {
      document.getElementById('mediaSelectionPopup').style.display = 'none';
    }

    function closeDiagram() {
      // Pause video if playing
      const v = document.getElementById('videoPlayer');
      if (v) v.pause();

      document.getElementById('diagramPopup').style.display = 'none';
    }

    // Clean up pagination as it's not strictly compatible with the drill-down unless we re-implement it per level
    document.getElementById('pagination').style.display = 'none';
    document.getElementById('backButton').style.display = 'none'; // Replaced by breadcrumbs

    // --- Strategic Trails (Pathfinder) Logic ---

    let activeTrailId = null;
    let trailCache = {};

    function initTrailsUI() {
      const container = document.getElementById('trailsContainer');
      const resetBtn = document.getElementById('resetTrailsBtn');
      if (!container) return;

      container.innerHTML = '';

      trailsConfig.forEach(trail => {
        const btn = document.createElement('button');
        btn.className = 'trail-btn';
        // Mission Control Layout
        btn.innerHTML = `
          <div class="trail-icon">${trail.icon || '🔹'}</div>
          <div class="trail-text">
            <div class="trail-title">${trail.name}</div>
            <div class="trail-subtext">${trail.subtext || trail.description}</div>
          </div>
        `;
        btn.style.setProperty('--trail-color', trail.color);
        btn.onclick = () => setActiveTrail(trail.id);
        btn.id = `btn-${trail.id}`;
        container.appendChild(btn);
      });

      if (resetBtn) {
        resetBtn.onclick = resetTrails;
      }
    }

    function getNodesInTrail(trailId) {
      if (trailCache[trailId]) return trailCache[trailId];

      const config = trailsConfig.find(t => t.id === trailId);
      if (!config) return [];

      let whitelist = null;
      if (config.cards && Array.isArray(config.cards) && config.cards.length > 0) {
        whitelist = new Set(config.cards);
        // Ensure seeds are always whitelisted
        config.seeds.forEach(s => whitelist.add(s));
      }

      let visited = new Set();
      // Queue for BFS: { id, depth }
      let queue = config.seeds.map(id => ({ id, depth: 0 }));
      let results = [];

      // Build adjacency map for faster lookup
      const adj = {};
      relationships.forEach(r => {
        // We traverse down 'contains'
        if (r.type === 'contains') {
          const src = r.source || r.from;
          const tgt = r.target || r.to;
          if (!adj[src]) adj[src] = [];
          adj[src].push(tgt);
        }
      });

      while (queue.length > 0) {
        const { id, depth } = queue.shift(); // Dequeue

        if (!visited.has(id)) {
          visited.add(id);

          // FILTER: Only add if whitelist is null OR id is in whitelist
          if (!whitelist || whitelist.has(id)) {
            results.push({ id, depth });
          } else {
            // If node is NOT in whitelist, do we stop traversing? 
            // Usually yes, if we want to hide that branch. 
            // Or do we traverse through invisible nodes? 
            // Let's assume we stop traversing this branch to reduce clutter.
            continue;
          }

          const children = adj[id] || [];
          children.forEach(childId => {
            if (!visited.has(childId)) {
              queue.push({ id: childId, depth: depth + 1 });
            }
          });
        }
      }

      trailCache[trailId] = results;
      return results;
    }

    function setActiveTrail(trailId) {
      const resetBtn = document.getElementById('resetTrailsBtn');
      activeTrailId = trailId;

      // Update UI Buttons
      document.querySelectorAll('.trail-btn').forEach(b => b.classList.remove('active'));
      const activeBtn = document.getElementById(`btn-${trailId}`);
      if (activeBtn) activeBtn.classList.add('active');

      if (resetBtn) resetBtn.style.display = 'block';

      // Switch to Network View
      updateVisualsForTrail(trailId);
    }

    function resetTrails() {
      activeTrailId = null;
      document.querySelectorAll('.trail-btn').forEach(b => b.classList.remove('active'));
      const resetBtn = document.getElementById('resetTrailsBtn');
      if (resetBtn) resetBtn.style.display = 'none';

      updateVisualsForTrail(null);
    }

    function updateVisualsForTrail(trailId) {
      const grid = document.getElementById('stackGrid');
      const networkContainer = document.getElementById('networkContainer');
      const navControls = document.getElementById('navControls');

      // RESET STATE (Grid View)
      if (!trailId) {
        grid.style.display = 'grid'; // Restore grid
        // Restore grid settings just in case
        grid.style.gridTemplateColumns = 'repeat(6, 1fr)';
        grid.style.gap = '20px';
        grid.style.padding = '20px';

        // Hide Network Overlay
        networkContainer.innerHTML = '';
        networkContainer.style.display = 'none';

        // Remove lingering tooltips (Fix for duplicate description bug)
        d3.selectAll('.network-tooltip').remove();

        // Show Grid Elements
        renderRoot();

        if (navControls) navControls.style.display = 'flex';
        // Also show sidebar elements if they were hidden?
        return;
      }

      // ACTIVATE NETWORK VIEW
      // grid.style.display = 'none'; // Optional: keep grid in background if overlay logic is different?

      // SHOW OVERLAY
      networkContainer.style.display = 'block';

      // navControls should be hidden or irrelevant as overlay covers them
      // if(navControls) navControls.style.display = 'none';

      // Render D3 Network
      renderNetwork(trailId);

      updateBreadcrumbs(); // Keep sidebar updated
    }

    function renderNetwork(trailId) {
      const container = document.getElementById('networkContainer');
      container.innerHTML = ''; // Clear

      const width = container.clientWidth;
      const height = container.clientHeight;

      const config = trailsConfig.find(t => t.id === trailId);
      const trailColor = config ? config.color : '#38bdf8';

      // --- UI CONTROLS ---

      // Close Button
      const closeBtn = document.createElement('button');
      closeBtn.className = 'close-network-btn';
      closeBtn.innerText = 'Close Network View';
      closeBtn.onclick = () => resetTrails();
      container.appendChild(closeBtn);

      // Controls Container
      const controls = document.createElement('div');
      controls.className = 'network-controls';
      controls.style.zIndex = '10005';
      controls.style.width = '200px'; // Wider to accommodate text

      // Seed Filter Controls
      const seedControlStr = document.createElement('div');
      seedControlStr.className = 'seed-filter-container';
      seedControlStr.innerHTML = `<label style="font-size:10px; font-weight:bold; text-transform:uppercase; margin-bottom:4px; display:block; color:white;">Active Clusters</label>`;

      const seedToggles = {}; // id -> checkbox element
      const activeSeeds = new Set(config.seeds); // All active initially

      config.seeds.forEach(seedId => {
        const sCard = cards[seedId];
        const label = document.createElement('label');
        label.className = 'seed-checkbox-label';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = true;
        checkbox.dataset.seed = seedId;

        // Event Listener added later after graph function is defined
        seedToggles[seedId] = checkbox;

        const span = document.createElement('span');
        span.innerText = sCard ? (sCard.title.length > 18 ? sCard.title.substring(0, 16) + '..' : sCard.title) : seedId;

        label.appendChild(checkbox);
        label.appendChild(span);
        seedControlStr.appendChild(label);
      });
      controls.appendChild(seedControlStr);

      // Depth Slider Control
      const depthControl = document.createElement('div');
      depthControl.style.cssText = `
        background: rgba(15, 23, 42, 0.95);
        padding: 12px;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.2);
        color: white;
        display: flex;
        flex-direction: column;
        gap: 5px;
        align-items: center;
        margin-bottom: 5px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      `;
      depthControl.innerHTML = `
        <label style="font-size:10px; font-weight:bold; text-transform:uppercase;">
           Depth: <span id="depthVal">All</span>
        </label>
        <input type="range" id="depthSlider" min="1" max="5" step="1" value="5" style="cursor:pointer; width: 100%;">
      `;
      controls.appendChild(depthControl);

      // Career Link Controls (Type 5)
      const careerControl = document.createElement('div');
      careerControl.className = 'seed-filter-container';
      careerControl.style.marginTop = '0px';
      careerControl.innerHTML = `
        <label style="font-size:10px; font-weight:bold; text-transform:uppercase; margin-bottom:4px; display:block; color:white;">Career Paths</label>
        
        <label class="seed-checkbox-label">
            <input type="checkbox" id="careerLinkVis" checked>
            <span>Show Links</span>
        </label>
        
        <div style="display:flex; flex-direction:column; gap:2px; margin-top:5px;">
            <label style="font-size:9px; color:#cbd5e1;">Length: <span id="careerLenVal">40</span></label>
            <input type="range" id="careerLenSlider" min="20" max="300" step="10" value="40" style="cursor:pointer;">
        </div>

        <div style="display:flex; flex-direction:column; gap:2px; margin-top:5px;">
            <label style="font-size:9px; color:#cbd5e1;">Tension: <span id="careerTenVal">1.0</span></label>
            <input type="range" id="careerTenSlider" min="0.1" max="2.0" step="0.1" value="1.0" style="cursor:pointer;">
        </div>
      `;
      controls.appendChild(careerControl);

      // Zoom Buttons
      // Zoom Buttons
      const zoomBtns = document.createElement('div');
      zoomBtns.style.cssText = 'display:flex; flex-direction:column; gap:8px; align-items:center; width:100%;';
      zoomBtns.innerHTML = `
          <div class="network-btn" id="zoomInBtn" title="Zoom In">+</div>
          <div class="network-btn" id="resetViewBtn" title="Reset View" style="font-size:12px">⟲</div>
          <div class="network-btn" id="zoomOutBtn" title="Zoom Out">-</div>
      `;
      controls.appendChild(zoomBtns);

      container.appendChild(controls);

      container.style.setProperty('--trail-color', trailColor);

      // --- DATA PREP (Graph) ---
      const trailNodes = getNodesInTrail(trailId);

      // MAP NODES TO SEEDS (Origin Tracking)
      const nodeToSeeds = new Map(); // nodeId -> Set of seedIds

      config.seeds.forEach(seedId => {
        const queue = [seedId];
        const visited = new Set([seedId]);

        if (!nodeToSeeds.has(seedId)) nodeToSeeds.set(seedId, new Set());
        nodeToSeeds.get(seedId).add(seedId);

        while (queue.length > 0) {
          const curr = queue.shift();
          // Find outgoing 'contains'
          relationships.forEach(r => {
            if (r.type === 'contains' && (r.from === curr || r.source === curr)) {
              const tgt = r.to || r.target;
              if (!visited.has(tgt)) {
                visited.add(tgt);
                queue.push(tgt);

                if (!nodeToSeeds.has(tgt)) nodeToSeeds.set(tgt, new Set());
                nodeToSeeds.get(tgt).add(seedId);
              }
            }
          });
        }
      });

      // Calculate Max Depth for Slider
      const maxDepth = Math.max(...trailNodes.map(n => n.depth));
      const bufferDepth = maxDepth + 1; // Ensure 'All' is covered

      const slider = controls.querySelector('#depthSlider');
      const depthLabel = controls.querySelector('#depthVal');

      slider.max = bufferDepth;
      slider.value = bufferDepth;
      depthLabel.innerText = "All";

      // Pre-process all possible nodes/links
      const allNodesData = trailNodes.map(n => {
        const card = cards[n.id];
        return {
          id: n.id,
          name: card ? card.title : n.id,
          type: card ? card.type : 'unknown',
          depth: n.depth
        };
      });

      const allNodeIds = new Set(allNodesData.map(n => n.id));
      const allLinksData = [];

      relationships.forEach(r => {
        const src = r.source || r.from;
        const tgt = r.target || r.to;
        if (allNodeIds.has(src) && allNodeIds.has(tgt)) {
          allLinksData.push({
            source: src,
            target: tgt,
            type: r.type,
            strength: r.strength || 1,
            _sourceId: src, // Store IDs for filtering later
            _targetId: tgt
          });
        }
      });

      // --- SVG SETUP ---
      const svg = d3.select("#networkContainer").append("svg")
        .attr("width", "100%")
        .attr("height", "100%")
        .style("cursor", "move");

      const g = svg.append("g");
      const linkGroup = g.append("g").attr("class", "links");
      const nodeGroup = g.append("g").attr("class", "nodes");

      // Arrow Marker
      svg.append("defs").append("marker")
        .attr("id", "arrowhead")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 90)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", trailColor);

      // Red Arrow Marker (Career Paths)
      svg.append("defs").append("marker")
        .attr("id", "arrowhead-red")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 90)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "#ef4444");

      const zoom = d3.zoom()
        .scaleExtent([0.1, 4])
        .on("zoom", (event) => g.attr("transform", event.transform));

      svg.call(zoom).on("dblclick.zoom", null);

      let simulation = null;

      // --- UPDATE FUNCTION ---
      function updateGraph(depthLimit) {
        if (depthLimit === undefined) {
          depthLimit = parseInt(slider.value) >= bufferDepth ? 999 : parseInt(slider.value);
        }

        // Filter Data
        const visibleNodes = allNodesData.filter(n => {
          // 1. Depth Check
          if (n.depth > depthLimit) return false;

          // 2. Seed Visibility Check
          // If node has tracked ancestors, at least one must be active
          const parentSeeds = nodeToSeeds.get(n.id);
          if (parentSeeds) {
            for (let s of parentSeeds) {
              if (activeSeeds.has(s)) return true;
            }
            return false; // Has parents but none active
          }
          return true; // Orphan/Independent (keep visible)
        });

        const visibleNodeIds = new Set(visibleNodes.map(n => n.id));

        const visibleLinks = allLinksData.filter(l => {
          const isConnected = visibleNodeIds.has(l._sourceId) && visibleNodeIds.has(l._targetId);
          if (!isConnected) return false;

          // Check Career Link Visibility
          if (l.strength >= 5 && !careerVisCheck.checked) return false;

          return true;
        }).map(l => ({ ...l })); // Clone to avoid mutation issues in D3

        // Stop old simulation
        if (simulation) simulation.stop();

        // Clear Groups (Simplest Approach for now)
        linkGroup.selectAll("*").remove();
        nodeGroup.selectAll("*").remove();

        const cLen = parseInt(careerLenSlider.value);
        const cTen = parseFloat(careerTenSlider.value);

        // --- FORCE SIMULATION ---
        simulation = d3.forceSimulation(visibleNodes)
          .force("link", d3.forceLink(visibleLinks)
            .id(d => d.id)
            .distance(d => d.strength >= 5 ? cLen : 150)
            .strength(d => d.strength >= 5 ? cTen : 0.1)
          )
          .force("charge", d3.forceManyBody().strength(-1000))
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collide", d3.forceCollide().radius(60));

        // Draw Links
        const link = linkGroup.selectAll("line")
          .data(visibleLinks)
          .enter().append("line")
          .attr("class", d => d.strength >= 5 ? "network-link high-tension-link" : "network-link")
          .style("stroke", d => d.strength >= 5 ? "#ef4444" : trailColor)
          .attr("marker-end", d => d.strength >= 5 ? "url(#arrowhead-red)" : "url(#arrowhead)");

        // Draw Nodes
        const node = nodeGroup.selectAll("g")
          .data(visibleNodes)
          .enter().append("g")
          .attr("class", "network-node")
          .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended))
          .on("dblclick", (event, d) => {
            event.stopPropagation();
            // 1. Close Network View
            resetTrails();

            // 2. Find Card Logic
            const targetId = d.id;
            const card = cards[targetId];
            if (!card) return;

            // 3. Find Parent to render context
            // Search relationships where target == d.id AND type == 'contains'
            const parentRel = relationships.find(r => (r.target === targetId || r.to === targetId) && r.type === 'contains');

            if (parentRel) {
              const parentId = parentRel.source || parentRel.from;
              const parentCard = cards[parentId];
              if (parentCard) {
                // Navigate to parent (renders siblings)
                navigateTo(parentCard);

                // Focus the specific card after a minimal DOM tick
                setTimeout(() => {
                  const el = document.getElementById(targetId);
                  if (el) focusStack(el);
                }, 50);
              }
            } else {
              // It's likely a root item or has no parent
              renderRoot();
              setTimeout(() => {
                const el = document.getElementById(targetId);
                if (el) focusStack(el);
              }, 50);
            }
          });

        node.append("rect")
          .attr("width", 160)
          .attr("height", 50)
          .attr("x", -80)
          .attr("y", -25)
          .attr("rx", 10)
          .style("--trail-color", trailColor);

        node.append("text")
          .attr("dy", 4)
          .each(function (d) {
            const el = d3.select(this);
            const name = d.name;
            if (name.length > 25) {
              el.text(name.substring(0, 23) + '...');
              el.append("title").text(name);
            } else {
              el.text(name);
            }
          });

        // Tick
        simulation.on("tick", () => {
          link
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);

          node.attr("transform", d => `translate(${d.x},${d.y})`);
        });

        // Tooltips re-attach
        attachTooltips(node, trailColor);
      }

      // --- INTERACTION HANDLERS ---

      const careerVisCheck = controls.querySelector('#careerLinkVis');
      const careerLenSlider = controls.querySelector('#careerLenSlider');
      const careerTenSlider = controls.querySelector('#careerTenSlider');

      careerVisCheck.onchange = () => updateGraph();

      careerLenSlider.oninput = (e) => {
        controls.querySelector('#careerLenVal').innerText = e.target.value;
        updateGraph();
      };

      careerTenSlider.oninput = (e) => {
        controls.querySelector('#careerTenVal').innerText = e.target.value;
        updateGraph();
      };

      // Wire up checkboxes
      Object.keys(seedToggles).forEach(seedId => {
        seedToggles[seedId].onchange = (e) => {
          if (e.target.checked) activeSeeds.add(seedId);
          else activeSeeds.delete(seedId);
          updateGraph();
        };
      });

      slider.oninput = (e) => {
        const val = parseInt(e.target.value);
        if (val >= bufferDepth) {
          depthLabel.innerText = "All";
          updateGraph(999);
        } else {
          depthLabel.innerText = "Level " + val;
          updateGraph(val);
        }
      };

      // Initial Draw
      updateGraph(999);

      // --- HELPERS ---
      function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }
      function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
      function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null; d.fy = null;
      }

      container.querySelector('#zoomInBtn').onclick = () => svg.transition().duration(300).call(zoom.scaleBy, 1.3);
      container.querySelector('#zoomOutBtn').onclick = () => svg.transition().duration(300).call(zoom.scaleBy, 0.7);
      container.querySelector('#resetViewBtn').onclick = () => {
        svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
        simulation.alpha(1).restart();
      };

      function attachTooltips(nodeSelection, color) {
        const tooltip = d3.select(".network-tooltip").empty() ?
          d3.select("body").append("div").attr("class", "network-tooltip") :
          d3.select(".network-tooltip");

        nodeSelection.on("mouseover", function (event, d) {
          const card = cards[d.id];
          const desc = card ? (card.description || "No details available") : "";
          tooltip.transition().duration(200).style("opacity", 1);
          tooltip.html(`
                <strong style="color:${color}; font-size:12px;">${d.name}</strong><br>
                <div style="margin-top:5px; font-size:10px; color:#cbd5e1;">${desc.substring(0, 150)}${desc.length > 150 ? '...' : ''}</div>
            `)
            .style("left", (event.pageX + 15) + "px")
            .style("top", (event.pageY - 28) + "px")
            .style("border-color", color);
          d3.select(this).select("rect").style("fill", color).style("stroke", "white");
        })
          .on("mouseout", function (d) {
            tooltip.transition().duration(500).style("opacity", 0);
            d3.select(this).select("rect").style("fill", "rgba(30, 41, 59, 0.9)").style("stroke", color);
          });
      }
    }

    // --- RECRUITER SKILL MATCH ---
    // --- LOCATE CARD LOGIC ---
    function locateCard(cardId) {
      console.log("Locating card:", cardId);
      const target = cards[cardId];
      if (!target) return;

      // 1. Reset View (Close trails if open)
      if (typeof resetTrails === 'function') resetTrails();

      // 2. Find Path to Root (Trace Parents)
      let path = [];
      let currentId = cardId;
      let iterations = 0;

      while (true) {
        const parentRel = relationships.find(r => (r.target === currentId || r.to === currentId) && r.type === 'contains');
        if (parentRel) {
          const parentId = parentRel.source || parentRel.from;
          const parentCard = cards[parentId];
          if (parentCard) {
            path.unshift(parentCard);
            currentId = parentId;
          } else { break; }
        } else { break; }
        iterations++;
        if (iterations > 20) break;
      }

      // 3. Navigate
      if (path.length === 0) {
        if (typeof renderRoot === 'function') window.renderRoot();
      } else {
        breadcrumbs = path; // global
        if (typeof jumpToCrumb === 'function') jumpToCrumb(breadcrumbs.length - 1);
      }

      // 4. Focus
      setTimeout(() => {
        const el = document.getElementById(cardId);
        if (el) {
          if (typeof focusStack === 'function') focusStack(el);
          el.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Additional visual cue
          el.style.boxShadow = '0 0 30px white';
          setTimeout(() => el.style.boxShadow = '', 1000);
        }
      }, 350);
    }

    function runSkillMatch() {
      const input = document.getElementById('skillInput').value;
      const resultsContainer = document.getElementById('skillResults');

      if (!input || input.trim().length === 0) {
        resultsContainer.innerHTML = '<div style="color:#64748b; font-style:italic; padding:10px;">Please enter keywords matching your job description...</div>';
        return;
      }

      const keywords = input.toLowerCase().split(/[\s,]+/).filter(k => k.length > 2 && !['and', 'the', 'for', 'with', 'this', 'that'].includes(k));

      if (keywords.length === 0) {
        resultsContainer.innerHTML = '<div style="color:#64748b; padding:10px;">Keywords too short.</div>';
        return;
      }

      const matches = [];
      Object.values(cards).forEach(card => {
        let score = 0;
        const title = (card.title || '').toLowerCase();
        const desc = (card.description || '').toLowerCase();

        keywords.forEach(k => {
          // Weight Title Matches higher
          if (title.includes(k)) score += 3;
          // Weight Description Matches lower
          if (desc.includes(k)) score += 1;
        });

        if (score > 0) {
          matches.push({ card, score });
        }
      });

      // Sort by absolute score
      matches.sort((a, b) => b.score - a.score);

      // Render
      resultsContainer.innerHTML = '';
      if (matches.length === 0) {
        resultsContainer.innerHTML = '<div style="color:#ef4444; padding:10px;">No exact matches found in portfolio.</div>';
        return;
      }

      resultsContainer.innerHTML = `<div style="color:#94a3b8; font-size:0.75rem; margin-bottom:10px; padding-left:5px;">Found ${matches.length} matching evidence cards:</div>`;

      matches.slice(0, 15).forEach(m => {
        const item = document.createElement('div');
        // Use inline styles to match sidebar-item feel but with extra distinctness
        item.style.padding = '8px 12px';
        item.style.marginBottom = '6px';
        item.style.background = 'rgba(255,255,255,0.03)';
        item.style.borderLeft = '3px solid var(--color-brand-accent-2)';
        item.style.borderRadius = '0 4px 4px 0';
        item.style.cursor = 'pointer';
        item.style.transition = 'all 0.2s';

        // Hover effect via JS
        item.onmouseenter = () => item.style.background = 'rgba(255,255,255,0.1)';
        item.onmouseleave = () => item.style.background = 'rgba(255,255,255,0.03)';

        // Click to locate (if we can implement robust navigation later)
        // Click to locate
        item.onclick = () => locateCard(m.card.id);

        item.innerHTML = `
          <div style="font-weight:700; font-size:0.8rem; color:#f1f5f9;">${m.card.title}</div>
          <div style="font-size:0.7rem; color:#64748b; margin-top:2px;">
            Relevance: <span style="color:var(--color-brand-accent-2);">${m.score}</span>
          </div>
        `;
        resultsContainer.appendChild(item);
      });
    }

    // Expose for debugging
    window.runSkillMatch = runSkillMatch;
    window.locateCard = locateCard;

    // --- SKILL MATCH POPUP LOGIC ---
    function closeSkillMatch() {
      const popup = document.getElementById('skillMatchPopup');
      if (popup) popup.style.display = 'none';
    }

    function runSkillMatch() {
      const input = document.getElementById('skillInput').value;
      const popup = document.getElementById('skillMatchPopup');
      const resultsContainer = document.getElementById('skillMatchResultsList');

      // Reset
      resultsContainer.innerHTML = '';
      popup.style.display = 'flex';

      if (!input || input.trim().length === 0) {
        resultsContainer.innerHTML = '<div style="color:#64748b; font-style:italic; padding:10px; text-align:center;">Please enter keywords matching your job description...</div>';
        return;
      }

      const keywords = input.toLowerCase().split(/[\s,]+/).filter(k => k.length > 2 && !['and', 'the', 'for', 'with', 'this', 'that'].includes(k));

      if (keywords.length === 0) {
        resultsContainer.innerHTML = '<div style="color:#64748b; padding:10px; text-align:center;">Keywords too short.</div>';
        return;
      }

      const matches = [];
      Object.values(cards).forEach(card => {
        let score = 0;
        const title = (card.title || '').toLowerCase();
        const desc = (card.description || '').toLowerCase();

        keywords.forEach(k => {
          if (title.includes(k)) score += 3;
          if (desc.includes(k)) score += 1;
        });

        if (score > 0) {
          matches.push({ card, score });
        }
      });

      matches.sort((a, b) => b.score - a.score);

      if (matches.length === 0) {
        resultsContainer.innerHTML = '<div style="color:#ef4444; padding:10px; text-align:center;">No exact matches found in portfolio.</div>';
        return;
      }

      const header = document.createElement('div');
      header.style.color = '#94a3b8';
      header.style.fontSize = '0.9rem';
      header.style.marginBottom = '15px';
      header.style.textAlign = 'center';
      header.innerHTML = `Found <span style="color:white; font-weight:bold;">${matches.length}</span> matching evidence cards:`;
      resultsContainer.appendChild(header);

      matches.slice(0, 20).forEach(m => {
        const item = document.createElement('div');
        item.style.padding = '12px 16px';
        item.style.marginBottom = '8px';
        item.style.background = 'rgba(255,255,255,0.03)';
        item.style.borderLeft = '4px solid var(--color-brand-accent-2)';
        item.style.borderRadius = '0 6px 6px 0';
        item.style.cursor = 'pointer';
        item.style.transition = 'all 0.2s';

        item.onmouseenter = () => item.style.background = 'rgba(255,255,255,0.1)';
        item.onmouseleave = () => item.style.background = 'rgba(255,255,255,0.03)';

        // Click to locate and close popup
        item.onclick = () => {
          closeSkillMatch();
          locateCard(m.card.id);
        };

        item.innerHTML = `
          <div style="font-weight:700; font-size:1rem; color:#f1f5f9;">${m.card.title}</div>
          <div style="font-size:0.8rem; color:#64748b; margin-top:4px;">
            Relevance Score: <span style="color:var(--color-brand-accent-2); font-weight:bold;">${m.score}</span>
          </div>
        `;
        resultsContainer.appendChild(item);
      });
    }

    window.closeSkillMatch = closeSkillMatch;
    window.runSkillMatch = runSkillMatch;

  </script>

</body>

</html>